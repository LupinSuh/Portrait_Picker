use crate::{mod_prelude_sys::*, core};

mod core_sys {
	use super::*;

	extern "C" {
		pub fn cv_Cholesky_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_Cholesky_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_LUT_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, lut: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LU_doubleX_size_t_int_doubleX_size_t_int(a: *mut f64, astep: size_t, m: i32, b: *mut f64, bstep: size_t, n: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_LU_floatX_size_t_int_floatX_size_t_int(a: *mut f32, astep: size_t, m: i32, b: *mut f32, bstep: size_t, n: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mahalanobis_const__InputArrayR_const__InputArrayR_const__InputArrayR(v1: *const c_void, v2: *const c_void, icovar: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_PCABackProject_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, result: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_double(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, retained_variance: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_const__OutputArrayR_int(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, eigenvalues: *const c_void, max_components: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_double(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, retained_variance: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_PCACompute_const__InputArrayR_const__InputOutputArrayR_const__OutputArrayR_int(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, max_components: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_PCAProject_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(data: *const c_void, mean: *const c_void, eigenvectors: *const c_void, result: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PSNR_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_PSNR_const__InputArrayR_const__InputArrayR_double(src1: *const c_void, src2: *const c_void, r: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_SVBackSubst_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(w: *const c_void, u: *const c_void, vt: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVDecomp_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVDecomp_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_abs_const_MatExprR(e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_abs_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_absdiff_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_addWeighted_const__InputArrayR_double_const__InputArrayR_double_double_const__OutputArrayR_int(src1: *const c_void, alpha: f64, src2: *const c_void, beta: f64, gamma: f64, dst: *const c_void, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_add_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_batchDistance_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dist: *const c_void, dtype: i32, nidx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_batchDistance_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__OutputArrayR_int_int_const__InputArrayR_int_bool(src1: *const c_void, src2: *const c_void, dist: *const c_void, dtype: i32, nidx: *const c_void, norm_type: i32, k: i32, mask: *const c_void, update: i32, crosscheck: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_and_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_not_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_not_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_or_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_bitwise_xor_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_borderInterpolate_int_int_int(p: i32, len: i32, border_type: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_broadcast_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, shape: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_calcCovarMatrix_const__InputArrayR_const__OutputArrayR_const__InputOutputArrayR_int(samples: *const c_void, covar: *const c_void, mean: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_calcCovarMatrix_const__InputArrayR_const__OutputArrayR_const__InputOutputArrayR_int_int(samples: *const c_void, covar: *const c_void, mean: *const c_void, flags: i32, ctype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_cartToPolar_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool(x: *const c_void, y: *const c_void, magnitude: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_checkHardwareSupport_int(feature: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_checkRange_const__InputArrayR(a: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_checkRange_const__InputArrayR_bool_PointX_double_double(a: *const c_void, quiet: bool, pos: *mut core::Point, min_val: f64, max_val: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_compare_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, cmpop: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_completeSymm_const__InputOutputArrayR(m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_completeSymm_const__InputOutputArrayR_bool(m: *const c_void, lower_to_upper: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_convertFp16_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_convertScaleAbs_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_convertScaleAbs_const__InputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_copyMakeBorder_const__InputArrayR_const__OutputArrayR_int_int_int_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, top: i32, bottom: i32, left: i32, right: i32, border_type: i32, value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_copyTo_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_countNonZero_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_cubeRoot_float(val: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_dct_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_dct_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_depthToString_int(depth: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_detail_check_failed_MatChannels_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_MatChannels_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_MatDepth_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_MatDepth_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_MatType_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_MatType_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_Size_LintG_const_CheckContextR(v: *const core::Size_<i32>, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_Size_LintG_const_Size_LintG_const_CheckContextR(v1: *const core::Size_<i32>, v2: *const core::Size_<i32>, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_bool_const_bool_const_CheckContextR(v1: bool, v2: bool, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_double_const_CheckContextR(v: f64, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_double_const_double_const_CheckContextR(v1: f64, v2: f64, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_float_const_CheckContextR(v: f32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_float_const_float_const_CheckContextR(v1: f32, v2: f32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_int_const_CheckContextR(v: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_int_const_int_const_CheckContextR(v1: i32, v2: i32, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_size_t_const_CheckContextR(v: size_t, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_size_t_const_size_t_const_CheckContextR(v1: size_t, v2: size_t, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_auto_const_stringR_const_CheckContextR(v1: *const c_char, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_false_const_bool_const_CheckContextR(v: bool, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_detail_check_failed_true_const_bool_const_CheckContextR(v: bool, ctx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_determinant_const__InputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_dft_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_dft_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, flags: i32, nonzero_rows: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertFromD3D10Texture2D_ID3D10Texture2DX_const__OutputArrayR(p_d3d10_texture_2d: *mut c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertFromD3D11Texture2D_ID3D11Texture2DX_const__OutputArrayR(p_d3d11_texture_2d: *mut c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertFromDirect3DSurface9_IDirect3DSurface9X_const__OutputArrayR(p_direct_3d_surface9: *mut c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertFromDirect3DSurface9_IDirect3DSurface9X_const__OutputArrayR_voidX(p_direct_3d_surface9: *mut c_void, dst: *const c_void, surface_shared_handle: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertToD3D10Texture2D_const__InputArrayR_ID3D10Texture2DX(src: *const c_void, p_d3d10_texture_2d: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertToD3D11Texture2D_const__InputArrayR_ID3D11Texture2DX(src: *const c_void, p_d3d11_texture_2d: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertToDirect3DSurface9_const__InputArrayR_IDirect3DSurface9X(src: *const c_void, p_direct_3d_surface9: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_convertToDirect3DSurface9_const__InputArrayR_IDirect3DSurface9X_voidX(src: *const c_void, p_direct_3d_surface9: *mut c_void, surface_shared_handle: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_directx_getTypeFromD3DFORMAT_const_int(id_3d_format: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_directx_getTypeFromDXGI_FORMAT_const_int(i_dxgi_format: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_directx_ocl_initializeContextFromD3D10Device_ID3D10DeviceX(p_d3d10_device: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_directx_ocl_initializeContextFromD3D11Device_ID3D11DeviceX(p_d3d11_device: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_directx_ocl_initializeContextFromDirect3DDevice9Ex_IDirect3DDevice9ExX(p_direct_3d_device9_ex: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_directx_ocl_initializeContextFromDirect3DDevice9_IDirect3DDevice9X(p_direct_3d_device9: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_divide_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_divide_double_const__InputArrayR_const__OutputArrayR(scale: f64, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_divide_double_const__InputArrayR_const__OutputArrayR_int(scale: f64, src2: *const c_void, dst: *const c_void, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_eigenNonSymmetric_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_eigen_const__InputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_eigen_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, eigenvalues: *const c_void, eigenvectors: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_error_const_ExceptionR(exc: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_error_int_const_StringR_const_charX_const_charX_int(code: i32, err: *const c_char, func: *const c_char, file: *const c_char, line: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_exp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_extractChannel_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, coi: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_fastAtan2_float_float(y: f32, x: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_findNonZero_const__InputArrayR_const__OutputArrayR(src: *const c_void, idx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_flipND_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, axis: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_flip_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flip_code: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_gemm_const__InputArrayR_const__InputArrayR_double_const__InputArrayR_double_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, alpha: f64, src3: *const c_void, beta: f64, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_getBuildInformation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getCPUFeaturesLine(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getCPUTickCount(ocvrs_return: *mut Result<i64>);
		pub fn cv_getDefaultAlgorithmHint(ocvrs_return: *mut Result<core::AlgorithmHint>);
		pub fn cv_getElemSize_int(typ: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_getHardwareFeatureName_int(feature: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getLogLevel(ocvrs_return: *mut Result<i32>);
		pub fn cv_getNumThreads(ocvrs_return: *mut Result<i32>);
		pub fn cv_getNumberOfCPUs(ocvrs_return: *mut Result<i32>);
		pub fn cv_getOptimalDFTSize_int(vecsize: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getThreadNum(ocvrs_return: *mut Result<i32>);
		pub fn cv_getTickCount(ocvrs_return: *mut Result<i64>);
		pub fn cv_getTickFrequency(ocvrs_return: *mut Result<f64>);
		pub fn cv_getVersionMajor() -> i32;
		pub fn cv_getVersionMinor() -> i32;
		pub fn cv_getVersionRevision() -> i32;
		pub fn cv_getVersionString(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_glob_String_vectorLStringGR(pattern: *const c_char, result: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_glob_String_vectorLStringGR_bool(pattern: *const c_char, result: *mut c_void, recursive: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_hasNonZero_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_haveOpenVX(ocvrs_return: *mut Result<bool>);
		pub fn cv_hconcat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_hconcat_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_idct_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_idct_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_idft_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_idft_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, flags: i32, nonzero_rows: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_inRange_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src: *const c_void, lowerb: *const c_void, upperb: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_insertChannel_const__InputArrayR_const__InputOutputArrayR_int(src: *const c_void, dst: *const c_void, coi: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_instr_getFlags(ocvrs_return: *mut Result<core::FLAGS>);
		pub fn cv_instr_resetTrace(ocvrs_return: *mut Result<()>);
		pub fn cv_instr_setFlags_FLAGS(mode_flags: core::FLAGS, ocvrs_return: *mut Result<()>);
		pub fn cv_instr_setUseInstrumentation_bool(flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_instr_useInstrumentation(ocvrs_return: *mut Result<bool>);
		pub fn cv_invert_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_invert_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_ipp_getIppErrorLocation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ipp_getIppFeatures(ocvrs_return: *mut Result<u64>);
		pub fn cv_ipp_getIppStatus(ocvrs_return: *mut Result<i32>);
		pub fn cv_ipp_getIppVersion(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ipp_setIppStatus_int(status: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ipp_setIppStatus_int_const_charX_const_charX_int(status: i32, funcname: *const c_char, filename: *const c_char, line: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ipp_setUseIPP_NotExact_bool(flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_ipp_setUseIPP_bool(flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_ipp_useIPP(ocvrs_return: *mut Result<bool>);
		pub fn cv_ipp_useIPP_NotExact(ocvrs_return: *mut Result<bool>);
		pub fn cv_kmeans_const__InputArrayR_int_const__InputOutputArrayR_TermCriteria_int_int(data: *const c_void, k: i32, best_labels: *const c_void, criteria: *const core::TermCriteria, attempts: i32, flags: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_kmeans_const__InputArrayR_int_const__InputOutputArrayR_TermCriteria_int_int_const__OutputArrayR(data: *const c_void, k: i32, best_labels: *const c_void, criteria: *const core::TermCriteria, attempts: i32, flags: i32, centers: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_log_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_magnitude_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, magnitude: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_max_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_max_const_MatR_const_MatR_MatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_max_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_max_const_UMatR_const_UMatR_UMatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_max_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_max_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_meanStdDev_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, mean: *const c_void, stddev: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_meanStdDev_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, mean: *const c_void, stddev: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_mean_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_mean_const__InputArrayR_const__InputArrayR(src: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_merge_const__InputArrayR_const__OutputArrayR(mv: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_minMaxIdx_const__InputArrayR_doubleX(src: *const c_void, min_val: *mut f64, ocvrs_return: *mut Result<()>);
		pub fn cv_minMaxIdx_const__InputArrayR_doubleX_doubleX_intX_intX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_minMaxLoc_const_SparseMatR_doubleX_doubleX(a: *const c_void, min_val: *mut f64, max_val: *mut f64, ocvrs_return: *mut Result<()>);
		pub fn cv_minMaxLoc_const_SparseMatR_doubleX_doubleX_intX_intX(a: *const c_void, min_val: *mut f64, max_val: *mut f64, min_idx: *mut i32, max_idx: *mut i32, ocvrs_return: *mut Result<()>);
		pub fn cv_minMaxLoc_const__InputArrayR_doubleX(src: *const c_void, min_val: *mut f64, ocvrs_return: *mut Result<()>);
		pub fn cv_minMaxLoc_const__InputArrayR_doubleX_doubleX_PointX_PointX_const__InputArrayR(src: *const c_void, min_val: *mut f64, max_val: *mut f64, min_loc: *mut core::Point, max_loc: *mut core::Point, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_min_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_min_const_MatR_const_MatR_MatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_min_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_min_const_UMatR_const_UMatR_UMatR(src1: *const c_void, src2: *const c_void, dst: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_min_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_min_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_mixChannels_const__InputArrayR_const__InputOutputArrayR_const_intX_size_t(src: *const c_void, dst: *const c_void, from_to: *const i32, npairs: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_mixChannels_const__InputArrayR_const__InputOutputArrayR_const_vectorLintGR(src: *const c_void, dst: *const c_void, from_to: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_mulSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, conj_b: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_mulTransposed_const__InputArrayR_const__OutputArrayR_bool(src: *const c_void, dst: *const c_void, a_ta: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_mulTransposed_const__InputArrayR_const__OutputArrayR_bool_const__InputArrayR_double_int(src: *const c_void, dst: *const c_void, a_ta: bool, delta: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_multiply_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, scale: f64, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_noArray() -> *mut c_void;
		pub fn cv_norm_const_SparseMatR_int(src: *const c_void, norm_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR(src1: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, src2: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_norm_const__InputArrayR_int_const__InputArrayR(src1: *const c_void, norm_type: i32, mask: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_normalize_const_SparseMatR_SparseMatR_double_int(src: *const c_void, dst: *mut c_void, alpha: f64, norm_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_normalize_const__InputArrayR_const__InputOutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_normalize_const__InputArrayR_const__InputOutputArrayR_double_double_int_int_const__InputArrayR(src: *const c_void, dst: *const c_void, alpha: f64, beta: f64, norm_type: i32, dtype: i32, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_attachContext_const_StringR_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_buildOptionsAddMatrixDescription_StringR_const_StringR_const__InputArrayR(build_options: *mut *mut c_void, name: *const c_char, _m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_checkOptimalVectorWidth_const_intX_const__InputArrayR(vector_widths: *const i32, src1: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_checkOptimalVectorWidth_const_intX_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_OclVectorStrategy(vector_widths: *const i32, src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, strat: core::OclVectorStrategy, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_convertFromBuffer_voidX_size_t_int_int_int_UMatR(cl_mem_buffer: *mut c_void, step: size_t, rows: i32, cols: i32, typ: i32, dst: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_convertFromImage_voidX_UMatR(cl_mem_image: *mut c_void, dst: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_convertTypeStr_int_int_int_charX(sdepth: i32, ddepth: i32, cn: i32, buf: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_convertTypeStr_int_int_int_charX_size_t(sdepth: i32, ddepth: i32, cn: i32, buf: *mut *mut c_void, buf_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_finish(ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_getOpenCLErrorString_int(error_code: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_getPlatfomsInfo_vectorLPlatformInfoGR(platform_info: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_haveAmdBlas(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveAmdFft(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveOpenCL(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_haveSVM(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_kernelToStr_const__InputArrayR(_kernel: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_kernelToStr_const__InputArrayR_int_const_charX(_kernel: *const c_void, ddepth: i32, name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_memopTypeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_predictOptimalVectorWidthMax_const__InputArrayR(src1: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidthMax_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidth_const__InputArrayR(src1: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_predictOptimalVectorWidth_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_OclVectorStrategy(src1: *const c_void, src2: *const c_void, src3: *const c_void, src4: *const c_void, src5: *const c_void, src6: *const c_void, src7: *const c_void, src8: *const c_void, src9: *const c_void, strat: core::OclVectorStrategy, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_setUseOpenCL_bool(flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_typeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_useOpenCL(ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_vecopTypeToStr_int(t: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatExprR_const_ScalarR(e: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_ScalarR_const_MatExprR(s: *const core::Scalar, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorA_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatExprR_double(e: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_double_const_MatExprR(s: f64, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorD_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_FileNodeIteratorR_const_FileNodeIteratorR(it1: *const c_void, it2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_operatorEQ_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorEQ_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorGE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorG_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorLE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorL_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_FileNodeIteratorR_const_FileNodeIteratorR(it1: *const c_void, it2: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_operatorNE_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNE_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorNOTB_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorOR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR(e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatExprR_const_ScalarR(e: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_ScalarR_const_MatExprR(s: *const core::Scalar, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorS_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_MatR_const_ScalarR(a: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorXOR_const_ScalarR_const_MatR(s: *const core::Scalar, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_const_MatExprR(e1: *const c_void, e2: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_const_MatR(e: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatExprR_double(e: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_const_MatExprR(m: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_const_MatR(a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_const_MatR_double(a: *const c_void, s: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_double_const_MatExprR(s: f64, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_operatorX_double_const_MatR(s: f64, a: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_parallel_for__const_RangeR_const_ParallelLoopBodyR(range: *const c_void, body: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_parallel_for__const_RangeR_const_ParallelLoopBodyR_double(range: *const c_void, body: *const c_void, nstripes: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_patchNaNs_const__InputOutputArrayR(a: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_patchNaNs_const__InputOutputArrayR_double(a: *const c_void, val: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_perspectiveTransform_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR(x: *const c_void, y: *const c_void, angle: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_phase_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(x: *const c_void, y: *const c_void, angle: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_polarToCart_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_bool(magnitude: *const c_void, angle: *const c_void, x: *const c_void, y: *const c_void, angle_in_degrees: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_pow_const__InputArrayR_double_const__OutputArrayR(src: *const c_void, power: f64, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_randShuffle_const__InputOutputArrayR(dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_randShuffle_const__InputOutputArrayR_double_RNGX(dst: *const c_void, iter_factor: f64, rng: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_randn_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(dst: *const c_void, mean: *const c_void, stddev: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_randu_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR(dst: *const c_void, low: *const c_void, high: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_DMatchR_const_DMatchR(node: *const c_void, value: *mut core::DMatch, default_value: *const core::DMatch, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_KeyPointR_const_KeyPointR(node: *const c_void, value: *mut c_void, default_value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_MatR(node: *const c_void, mat: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_MatR_const_MatR(node: *const c_void, mat: *mut c_void, default_mat: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_SparseMatR(node: *const c_void, mat: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_SparseMatR_const_SparseMatR(node: *const c_void, mat: *mut c_void, default_mat: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_doubleR_double(node: *const c_void, value: *mut f64, default_value: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_floatR_float(node: *const c_void, value: *mut f32, default_value: f32, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_int64_tR_int64_t(node: *const c_void, value: *mut i64, default_value: i64, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_intR_int(node: *const c_void, value: *mut i32, default_value: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_stringR_const_stringR(node: *const c_void, value: *mut *mut c_void, default_value: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_vectorLDMatchGR(node: *const c_void, matches: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_read_const_FileNodeR_vectorLKeyPointGR(node: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_rectangleIntersectionArea_const_Rect2dR_const_Rect2dR(a: *const core::Rect2d, b: *const core::Rect2d, ocvrs_return: *mut Result<f64>);
		pub fn cv_reduceArgMax_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, axis: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_reduceArgMax_const__InputArrayR_const__OutputArrayR_int_bool(src: *const c_void, dst: *const c_void, axis: i32, last_index: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_reduceArgMin_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, axis: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_reduceArgMin_const__InputArrayR_const__OutputArrayR_int_bool(src: *const c_void, dst: *const c_void, axis: i32, last_index: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_reduce_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, dim: i32, rtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_reduce_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, dim: i32, rtype: i32, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_repeat_const_MatR_int_int(src: *const c_void, ny: i32, nx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_repeat_const__InputArrayR_int_int_const__OutputArrayR(src: *const c_void, ny: i32, nx: i32, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_rotate_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, rotate_code: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_samples_addSamplesDataSearchPath_const_StringR(path: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_samples_addSamplesDataSearchSubDirectory_const_StringR(subdir: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_samples_findFileOrKeep_const_StringR(relative_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFileOrKeep_const_StringR_bool(relative_path: *const c_char, silent_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFile_const_StringR(relative_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_samples_findFile_const_StringR_bool_bool(relative_path: *const c_char, required: bool, silent_mode: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_scaleAdd_const__InputArrayR_double_const__InputArrayR_const__OutputArrayR(src1: *const c_void, alpha: f64, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_setBreakOnError_bool(flag: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_setIdentity_const__InputOutputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_setIdentity_const__InputOutputArrayR_const_ScalarR(mtx: *const c_void, s: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_setLogLevel_int(level: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_setNumThreads_int(nthreads: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_setRNGSeed_int(seed: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_setUseOpenVX_bool(flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_setUseOptimized_bool(onoff: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_solveCubic_const__InputArrayR_const__OutputArrayR(coeffs: *const c_void, roots: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solveLP_const__InputArrayR_const__InputArrayR_const__OutputArrayR(func: *const c_void, constr: *const c_void, z: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_solveLP_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double(func: *const c_void, constr: *const c_void, z: *const c_void, constr_eps: f64, ocvrs_return: *mut Result<i32>);
		pub fn cv_solvePoly_const__InputArrayR_const__OutputArrayR(coeffs: *const c_void, roots: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_solvePoly_const__InputArrayR_const__OutputArrayR_int(coeffs: *const c_void, roots: *const c_void, max_iters: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_solve_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_solve_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_sortIdx_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_sort_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_split_const_MatR_MatX(src: *const c_void, mvbegin: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_split_const__InputArrayR_const__OutputArrayR(m: *const c_void, mv: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_sqrt_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_subtract_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__InputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, dtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_sum_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_swap_MatR_MatR(a: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_swap_UMatR_UMatR(a: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_tempfile(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_tempfile_const_charX(suffix: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_terminate_int_const_StringR_const_charX_const_charX_int(code: i32, err: *const c_char, func: *const c_char, file: *const c_char, line: i32);
		pub fn cv_theRNG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_trace_const__InputArrayR(mtx: *const c_void, ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_transform_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_transposeND_const__InputArrayR_const_vectorLintGR_const__OutputArrayR(src: *const c_void, order: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_transpose_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_typeToString_int(typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_useOpenVX(ocvrs_return: *mut Result<bool>);
		pub fn cv_useOptimized(ocvrs_return: *mut Result<bool>);
		pub fn cv_utils_copyMatAndDumpNamedArguments_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_copyMatAndDumpNamedArguments_const__InputArrayR_const__OutputArrayR_const_FunctionParamsR(src: *const c_void, dst: *const c_void, params: *const core::FunctionParams, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpBool_bool(argument: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpCString_const_charX(argument: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpDouble_double(argument: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpFloat_float(argument: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputArrayOfArrays_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputArray_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputOutputArrayOfArrays_const__InputOutputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInputOutputArray_const__InputOutputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInt64_int64_t(argument: i64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpInt_int(argument: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRange_const_RangeR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRect_const_RectR(argument: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpRotatedRect_const_RotatedRectR(argument: *const core::RotatedRect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpSizeT_size_t(argument: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpString_const_StringR(argument: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpTermCriteria_const_TermCriteriaR(argument: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVec2i(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVec2i_const_Vec2i(value: *const core::Vec2i, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfDouble_const_vectorLdoubleGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfInt_const_vectorLintGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_dumpVectorOfRect_const_vectorLRectGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_fs_getCacheDirectoryForDownloads(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_generateVectorOfInt_size_t_vectorLintGR(len: size_t, vec: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_generateVectorOfMat_size_t_int_int_int_vectorLMatGR(len: size_t, rows: i32, cols: i32, dtype: i32, vec: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_generateVectorOfRect_size_t_vectorLRectGR(len: size_t, vec: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_getThreadID(ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_logging_getLogLevel(ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_getLogTagLevel_const_charX(tag: *const c_char, ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_internal_getGlobalLogTag(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_logging_internal_replaceWriteLogMessageEx_WriteLogMessageExFuncType(f: Option<unsafe extern "C" fn(core::LogLevel, *const c_char, *const c_char, i32, *const c_char, *const c_char) -> ()>, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_logging_internal_replaceWriteLogMessage_WriteLogMessageFuncType(f: Option<unsafe extern "C" fn(core::LogLevel, *const c_char) -> ()>, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_logging_internal_writeLogMessageEx_LogLevel_const_charX_const_charX_int_const_charX_const_charX(log_level: core::LogLevel, tag: *const c_char, file: *const c_char, line: i32, func: *const c_char, message: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_logging_internal_writeLogMessage_LogLevel_const_charX(log_level: core::LogLevel, message: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_logging_registerLogTag_LogTagX(plogtag: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_logging_setLogLevel_LogLevel(log_level: core::LogLevel, ocvrs_return: *mut Result<core::LogLevel>);
		pub fn cv_utils_logging_setLogTagLevel_const_charX_LogLevel(tag: *const c_char, level: core::LogLevel, ocvrs_return: *mut Result<()>);
		pub fn cv_utils_nested_testEchoBooleanFunction_bool(flag: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_utils_testAsyncArray_const__InputArrayR(argument: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testAsyncException(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_const_RectR(rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_int(value: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverloadResolution_int_const_PointR(value: i32, point: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testOverwriteNativeMethod_int(argument: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_testRaiseGeneralException(ocvrs_return: *mut Result<()>);
		pub fn cv_utils_testReservedKeywordConversion_int(positional_argument: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testReservedKeywordConversion_int_int_int(positional_argument: i32, lambda: i32, from: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testRotatedRectVector_float_float_float_float_float(x: f32, y: f32, w: f32, h: f32, angle: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_testRotatedRect_float_float_float_float_float(x: f32, y: f32, w: f32, h: f32, angle: f32, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_va_intel_convertFromVASurface_VADisplay_VASurfaceID_Size_const__OutputArrayR(display: core::VADisplay, surface: core::VASurfaceID, size: *const core::Size, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_va_intel_convertToVASurface_VADisplay_const__InputArrayR_VASurfaceID_Size(display: core::VADisplay, src: *const c_void, surface: core::VASurfaceID, size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_va_intel_ocl_initializeContextFromVA_VADisplay(display: core::VADisplay, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_va_intel_ocl_initializeContextFromVA_VADisplay_bool(display: core::VADisplay, try_interop: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_vconcat_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_vconcat_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_writeScalar_FileStorageR_const_StringR(fs: *mut c_void, value: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_writeScalar_FileStorageR_double(fs: *mut c_void, value: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_writeScalar_FileStorageR_float(fs: *mut c_void, value: f32, ocvrs_return: *mut Result<()>);
		pub fn cv_writeScalar_FileStorageR_int(fs: *mut c_void, value: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_writeScalar_FileStorageR_int64_t(fs: *mut c_void, value: i64, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_const_MatR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_const_SparseMatR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_const_StringR(fs: *mut c_void, name: *const c_char, value: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_const_vectorLDMatchGR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_const_vectorLKeyPointGR(fs: *mut c_void, name: *const c_char, value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_double(fs: *mut c_void, name: *const c_char, value: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_float(fs: *mut c_void, name: *const c_char, value: f32, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_int(fs: *mut c_void, name: *const c_char, value: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_write_FileStorageR_const_StringR_int64_t(fs: *mut c_void, name: *const c_char, value: i64, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_Algorithm(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Algorithm_clear(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_write_const_const_PtrLFileStorageGR_const_StringR(instance: *const c_void, fs: *const c_void, name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_write_const_const_PtrLFileStorageGR(instance: *const c_void, fs: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Algorithm_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_Algorithm_getDefaultName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Algorithm_to_ConjGradSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Algorithm_to_DownhillSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Algorithm_to_MinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Algorithm_delete(instance: *mut c_void);
		pub fn cv_AsyncArray_AsyncArray() -> *mut c_void;
		pub fn cv_AsyncArray_AsyncArray_const_AsyncArrayR(o: *const c_void) -> *mut c_void;
		pub fn cv_AsyncArray_operatorST_const_AsyncArrayR(instance: *mut c_void, o: *const c_void);
		pub fn cv_AsyncArray_release(instance: *mut c_void);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR(instance: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR_int64_t(instance: *const c_void, dst: *const c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_get_const_const__OutputArrayR_double(instance: *const c_void, dst: *const c_void, timeout_ns: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_wait_for_const_int64_t(instance: *const c_void, timeout_ns: i64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_wait_for_const_double(instance: *const c_void, timeout_ns: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_AsyncArray_valid_const(instance: *const c_void) -> bool;
		pub fn cv_AsyncArray_AsyncArray_AsyncArrayRR(o: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncArray_operatorST_AsyncArrayRR(instance: *mut c_void, o: *mut c_void);
		pub fn cv_AsyncArray_delete(instance: *mut c_void);
		pub fn cv_AsyncPromise_AsyncPromise() -> *mut c_void;
		pub fn cv_AsyncPromise_AsyncPromise_const_AsyncPromiseR(o: *const c_void) -> *mut c_void;
		pub fn cv_AsyncPromise_operatorST_const_AsyncPromiseR(instance: *mut c_void, o: *const c_void);
		pub fn cv_AsyncPromise_release(instance: *mut c_void);
		pub fn cv_AsyncPromise_getArrayResult(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise_setValue_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_AsyncPromise_setException_const_ExceptionR(instance: *mut c_void, exception: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_AsyncPromise_AsyncPromise_AsyncPromiseRR(o: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_AsyncPromise_operatorST_AsyncPromiseRR(instance: *mut c_void, o: *mut c_void);
		pub fn cv_AsyncPromise__getImpl_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_AsyncPromise_delete(instance: *mut c_void);
		pub fn cv_CommandLineParser_CommandLineParser_int_const_charXX_const_StringR(argc: i32, argv: *const *const c_char, keys: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_CommandLineParser_const_CommandLineParserR(parser: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_operatorST_const_CommandLineParserR(instance: *mut c_void, parser: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CommandLineParser_getPathToApplication_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_bool_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_bool_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_int_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_int_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_double_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_double_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_cv_String_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_cv_String_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_uint64_t_const_const_StringR_bool(instance: *const c_void, name: *const c_char, space_delete: bool, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_get_uint64_t_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_get_bool_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_bool_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_get_int_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_int_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_CommandLineParser_get_double_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_double_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_CommandLineParser_get_cv_String_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_cv_String_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CommandLineParser_get_uint64_t_const_int_bool(instance: *const c_void, index: i32, space_delete: bool, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_get_uint64_t_const_int(instance: *const c_void, index: i32, ocvrs_return: *mut Result<u64>);
		pub fn cv_CommandLineParser_has_const_const_StringR(instance: *const c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_check_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CommandLineParser_about_const_StringR(instance: *mut c_void, message: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_CommandLineParser_printMessage_const(instance: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CommandLineParser_printErrors_const(instance: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CommandLineParser_delete(instance: *mut c_void);
		pub fn cv_ConjGradSolver_create_const_PtrLFunctionGR_TermCriteria(f: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ConjGradSolver_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ConjGradSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ConjGradSolver_to_MinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ConjGradSolver_delete(instance: *mut c_void);
		pub fn cv_DMatch_DMatch(ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_DMatch_int_int_float(_query_idx: i32, _train_idx: i32, _distance: f32, ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_DMatch_int_int_int_float(_query_idx: i32, _train_idx: i32, _img_idx: i32, _distance: f32, ocvrs_return: *mut Result<core::DMatch>);
		pub fn cv_DMatch_operatorL_const_const_DMatchR(instance: *const core::DMatch, m: *const core::DMatch, ocvrs_return: *mut Result<bool>);
		pub fn cv_DownhillSolver_getInitStep_const_const__OutputArrayR(instance: *const c_void, step: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DownhillSolver_setInitStep_const__InputArrayR(instance: *mut c_void, step: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DownhillSolver_create_const_PtrLFunctionGR_const__InputArrayR_TermCriteria(f: *const c_void, init_step: *const c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DownhillSolver_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DownhillSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DownhillSolver_to_MinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_DownhillSolver_delete(instance: *mut c_void);
		pub fn cv_Exception_Exception(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_Exception_int_const_StringR_const_StringR_const_StringR_int(_code: i32, _err: *const c_char, _func: *const c_char, _file: *const c_char, _line: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Exception_what_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_formatMessage(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Exception_propMsg_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propMsg_const_String(instance: *mut c_void, val: *const c_char);
		pub fn cv_Exception_propCode_const(instance: *const c_void) -> i32;
		pub fn cv_Exception_propCode_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Exception_propErr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propErr_const_String(instance: *mut c_void, val: *const c_char);
		pub fn cv_Exception_propFunc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propFunc_const_String(instance: *mut c_void, val: *const c_char);
		pub fn cv_Exception_propFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Exception_propFile_const_String(instance: *mut c_void, val: *const c_char);
		pub fn cv_Exception_propLine_const(instance: *const c_void) -> i32;
		pub fn cv_Exception_propLine_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Exception_delete(instance: *mut c_void);
		pub fn cv_FileNode_FileNode(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_FileNode_const_FileStorageX_size_t_size_t(fs: *const c_void, block_idx: size_t, ofs: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_FileNode_const_FileNodeR(node: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operatorST_const_FileNodeR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FileNode_operator___const_const_StringR(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_const_charX(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_keys_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileNode_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isNone_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isSeq_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isMap_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isInt_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isReal_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isString_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isNamed_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNode_rawSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNode_operator_int_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileNode_operator_int64_t_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_FileNode_operator_float_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FileNode_operator_double_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FileNode_operator_std_string_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_isMap_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isSeq_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isCollection_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isEmptyCollection_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_isFlow_int(flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNode_ptr(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_FileNode_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_FileNode_begin_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_end_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_readRaw_const_const_StringR_voidX_size_t(instance: *const c_void, fmt: *const c_char, vec: *mut c_void, len: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_FileNode_setValue_int_const_voidX_int(instance: *mut c_void, typ: i32, value: *const c_void, len: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_FileNode_real_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FileNode_string_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_mat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNode_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_FileNode_propBlockIdx_const(instance: *const c_void) -> size_t;
		pub fn cv_FileNode_propBlockIdx_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_FileNode_propOfs_const(instance: *const c_void) -> size_t;
		pub fn cv_FileNode_propOfs_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_FileNode_delete(instance: *mut c_void);
		pub fn cv_FileNodeIterator_FileNodeIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeR_bool(node: *const c_void, seek_end: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_FileNodeIterator_const_FileNodeIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_operatorST_const_FileNodeIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FileNodeIterator_operatorX_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_readRaw_const_StringR_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *mut c_void, len: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileNodeIterator_remaining_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_FileNodeIterator_equalTo_const_const_FileNodeIteratorR(instance: *const c_void, it: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileNodeIterator_delete(instance: *mut c_void);
		pub fn cv_FileStorage_FileStorage(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_FileStorage_const_StringR_int_const_StringR(filename: *const c_char, flags: i32, encoding: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_FileStorage_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_open_const_StringR_int_const_StringR(instance: *mut c_void, filename: *const c_char, flags: i32, encoding: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_open_const_StringR_int(instance: *mut c_void, filename: *const c_char, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_isOpened_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_FileStorage_release(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_releaseAndGetString(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_getFirstTopLevelNode_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_root_const_int(instance: *const c_void, streamidx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_root_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_operator___const_const_StringR(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_operator___const_const_charX(instance: *const c_void, nodename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_write_const_StringR_int(instance: *mut c_void, name: *const c_char, val: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_write_const_StringR_int64_t(instance: *mut c_void, name: *const c_char, val: i64, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_write_const_StringR_double(instance: *mut c_void, name: *const c_char, val: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_write_const_StringR_const_StringR(instance: *mut c_void, name: *const c_char, val: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_write_const_StringR_const_MatR(instance: *mut c_void, name: *const c_char, val: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_write_const_StringR_const_vectorLStringGR(instance: *mut c_void, name: *const c_char, val: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_writeRaw_const_StringR_const_voidX_size_t(instance: *mut c_void, fmt: *const c_char, vec: *const c_void, len: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_writeComment_const_StringR_bool(instance: *mut c_void, comment: *const c_char, append: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_writeComment_const_StringR(instance: *mut c_void, comment: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_startWriteStruct_const_StringR_int_const_StringR(instance: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_startWriteStruct_const_StringR_int(instance: *mut c_void, name: *const c_char, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_endWriteStruct(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FileStorage_getDefaultObjectName_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FileStorage_getFormat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FileStorage_propState_const(instance: *const c_void) -> i32;
		pub fn cv_FileStorage_propState_const_int(instance: *mut c_void, val: i32);
		pub fn cv_FileStorage_propElname_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_FileStorage_propElname_const_string(instance: *mut c_void, val: *const c_char);
		pub fn cv_FileStorage_delete(instance: *mut c_void);
		pub fn cv_Formatted_next(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatted_reset(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatted_delete(instance: *mut c_void);
		pub fn cv_Formatter_format_const_const_MatR(instance: *const c_void, mtx: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_set16fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_set16fPrecision(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_set32fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_set32fPrecision(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_set64fPrecision_int(instance: *mut c_void, p: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_set64fPrecision(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_setMultiline_bool(instance: *mut c_void, ml: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_setMultiline(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Formatter_get_FormatType(fmt: core::Formatter_FormatType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_get(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Formatter_delete(instance: *mut c_void);
		pub fn cv_Hamming_operator___const_const_unsigned_charX_const_unsigned_charX_int(instance: *const c_void, a: *const u8, b: *const u8, size: i32, ocvrs_return: *mut Result<core::Hamming_ResultType>);
		pub fn cv_Hamming_defaultNew_const() -> *mut c_void;
		pub fn cv_Hamming_delete(instance: *mut c_void);
		pub fn cv_KeyPoint_KeyPoint(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_Point2f_float_float_float_int_int(pt: *const core::Point2f, size: f32, angle: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_Point2f_float(pt: *const core::Point2f, size: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_float_float_float_float_float_int_int(x: f32, y: f32, size: f32, angle: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_KeyPoint_float_float_float(x: f32, y: f32, size: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_KeyPoint_hash_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_KeyPoint_convert_const_vectorLKeyPointGR_vectorLPoint2fGR_const_vectorLintGR(keypoints: *const c_void, points2f: *mut c_void, keypoint_indexes: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_KeyPoint_convert_const_vectorLKeyPointGR_vectorLPoint2fGR(keypoints: *const c_void, points2f: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_KeyPoint_convert_const_vectorLPoint2fGR_vectorLKeyPointGR_float_float_int_int(points2f: *const c_void, keypoints: *mut c_void, size: f32, response: f32, octave: i32, class_id: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_KeyPoint_convert_const_vectorLPoint2fGR_vectorLKeyPointGR(points2f: *const c_void, keypoints: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_KeyPoint_overlap_const_KeyPointR_const_KeyPointR(kp1: *const c_void, kp2: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_KeyPoint_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_KeyPoint_propPt_const(instance: *const c_void, ocvrs_return: *mut core::Point2f);
		pub fn cv_KeyPoint_propPt_const_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn cv_KeyPoint_propSize_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_propSize_const_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_propAngle_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_propAngle_const_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_propResponse_const(instance: *const c_void) -> f32;
		pub fn cv_KeyPoint_propResponse_const_float(instance: *mut c_void, val: f32);
		pub fn cv_KeyPoint_propOctave_const(instance: *const c_void) -> i32;
		pub fn cv_KeyPoint_propOctave_const_int(instance: *mut c_void, val: i32);
		pub fn cv_KeyPoint_propClass_id_const(instance: *const c_void) -> i32;
		pub fn cv_KeyPoint_propClass_id_const_int(instance: *mut c_void, val: i32);
		pub fn cv_KeyPoint_delete(instance: *mut c_void);
		pub fn cv_LDA_LDA_int(num_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA_const__InputArrayR_const__InputArrayR_int(src: *const c_void, labels: *const c_void, num_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_LDA_const__InputArrayR_const__InputArrayR(src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_LDA_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_LDA_save_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LDA_load_const_FileStorageR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LDA_compute_const__InputArrayR_const__InputArrayR(instance: *mut c_void, src: *const c_void, labels: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LDA_project_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_reconstruct_const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_eigenvectors_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_eigenvalues_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_subspaceProject_const__InputArrayR_const__InputArrayR_const__InputArrayR(w: *const c_void, mean: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_subspaceReconstruct_const__InputArrayR_const__InputArrayR_const__InputArrayR(w: *const c_void, mean: *const c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LDA_delete(instance: *mut c_void);
		pub fn cv_Mat_Mat() -> *mut c_void;
		pub fn cv_Mat_Mat_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_const_ScalarR(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_const_ScalarR(size: *const core::Size, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int(ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int(sizes: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_const_ScalarR(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_const_ScalarR(sizes: *const c_void, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_voidX_size_t(rows: i32, cols: i32, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_int_int_voidX(rows: i32, cols: i32, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_voidX_size_t(size: *const core::Size, typ: i32, data: *mut c_void, step: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_Size_int_voidX(size: *const core::Size, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_voidX_const_size_tX(ndims: i32, sizes: *const i32, typ: i32, data: *mut c_void, steps: *const size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_int_const_intX_int_voidX(ndims: i32, sizes: *const i32, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_voidX_const_size_tX(sizes: *const c_void, typ: i32, data: *mut c_void, steps: *const size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_vectorLintGR_int_voidX(sizes: *const c_void, typ: i32, data: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RangeR_const_RangeR(m: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_MatR_const_RangeR(m: *mut c_void, row_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RangeR(m: *const c_void, row_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_MatR_const_RangeR_const_RangeR(m: *mut c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_RectR(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_MatR_const_RectR(m: *mut c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_const_MatR_const_vectorLRangeGR(m: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_Mat_MatR_const_vectorLRangeGR(m: *mut c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operatorST_const_MatExprR(instance: *mut c_void, expr: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_getUMat_const_AccessFlag_UMatUsageFlags(instance: *const c_void, access_flags: core::AccessFlag, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_getUMat_const_AccessFlag(instance: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_row_int(instance: *mut c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_col_int(instance: *mut c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_int_int(instance: *mut c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_rowRange_const_RangeR(instance: *mut c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_int_int(instance: *mut c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_colRange_const_RangeR(instance: *mut c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_int(instance: *mut c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_diag_const_MatR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_copyTo_const_const__OutputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, m: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, m: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_convertTo_const_const__OutputArrayR_int(instance: *const c_void, m: *const c_void, rtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_assignTo_const_MatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_assignTo_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_operatorST_const_ScalarR(instance: *mut c_void, s: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_setTo_const__InputArrayR_const__InputArrayR(instance: *mut c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_setTo_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_int(instance: *mut c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int(instance: *const c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_int_int(instance: *mut c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_int_const_intX(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_int_int_const_intX(instance: *mut c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_const_int_const_vectorLintGR(instance: *const c_void, cn: i32, newshape: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reshape_int_const_vectorLintGR(instance: *mut c_void, cn: i32, newshape: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_reinterpret_const_int(instance: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_inv_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_mul_const_const__InputArrayR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_mul_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_cross_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_dot_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_Mat_zeros_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_zeros_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_eye_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_eye_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_create_int_const_intX_int(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_create_const_vectorLintGR_int(instance: *mut c_void, sizes: *const c_void, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_addref(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_release(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_deallocate(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_reserve_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_reserveBuffer_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_resize_size_t(instance: *mut c_void, sz: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_resize_size_t_const_ScalarR(instance: *mut c_void, sz: size_t, s: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_push_back_const_MatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_pop_back_size_t(instance: *mut c_void, nelems: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_pop_back(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___Range_Range(instance: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_RectR(instance: *mut c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_operator___const_vectorLRangeGR(instance: *mut c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_isContinuous_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_isSubmatrix_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_Mat_type_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_step1_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_empty_const(instance: *const c_void) -> bool;
		pub fn cv_Mat_total_const(instance: *const c_void) -> size_t;
		pub fn cv_Mat_total_const_int_int(instance: *const c_void, start_dim: i32, end_dim: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_total_const_int(instance: *const c_void, start_dim: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_Mat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mat_checkVector_const_int(instance: *const c_void, elem_channels: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Mat_ptr_int(instance: *mut c_void, i0: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int(instance: *const c_void, i0: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_int_int(instance: *mut c_void, row: i32, col: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int_int(instance: *const c_void, row: i32, col: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_ptr_const_intX(instance: *mut c_void, idx: *const i32, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_Mat_ptr_const_const_intX(instance: *const c_void, idx: *const i32, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_Mat_operatorST_MatRR(instance: *mut c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Mat_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_Mat_getDataDump_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Mat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propFlags_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propDims_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propRows_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propRows_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propCols_const(instance: *const c_void) -> i32;
		pub fn cv_Mat_propCols_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Mat_propData_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_Mat_propData_unsigned_charX(instance: *mut c_void, val: *const u8);
		pub fn cv_Mat_propDatastart_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propDataend_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propDatalimit_const(instance: *const c_void) -> *const u8;
		pub fn cv_Mat_propU(instance: *mut c_void) -> *mut c_void;
		pub fn cv_Mat_propU_UMatDataX(instance: *mut c_void, val: *const c_void);
		pub fn cv_Mat_propSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Mat_propSize_const_MatSize(instance: *mut c_void, val: *const c_void);
		pub fn cv_Mat_propStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Mat_delete(instance: *mut c_void);
		pub fn cv_MatConstIterator_MatConstIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX(_m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_int_int(_m: *const c_void, _row: i32, _col: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_int(_m: *const c_void, _row: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatX_Point(_m: *const c_void, _pt: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_MatConstIterator_const_MatConstIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_operatorST_const_MatConstIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatConstIterator_operatorX_const(instance: *const c_void, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_MatConstIterator_operator___const_ptrdiff_t(instance: *const c_void, i: ptrdiff_t, ocvrs_return: *mut Result<*const u8>);
		pub fn cv_MatConstIterator_operatorSS(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatConstIterator_pos_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_MatConstIterator_pos_const_intX(instance: *const c_void, _idx: *mut i32, ocvrs_return: *mut Result<()>);
		pub fn cv_MatConstIterator_lpos_const(instance: *const c_void, ocvrs_return: *mut Result<ptrdiff_t>);
		pub fn cv_MatConstIterator_seek_ptrdiff_t_bool(instance: *mut c_void, ofs: ptrdiff_t, relative: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_MatConstIterator_seek_ptrdiff_t(instance: *mut c_void, ofs: ptrdiff_t, ocvrs_return: *mut Result<()>);
		pub fn cv_MatConstIterator_seek_const_intX_bool(instance: *mut c_void, _idx: *const i32, relative: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_MatConstIterator_seek_const_intX(instance: *mut c_void, _idx: *const i32, ocvrs_return: *mut Result<()>);
		pub fn cv_MatConstIterator_type_const(instance: *const c_void) -> i32;
		pub fn cv_MatConstIterator_propM_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatConstIterator_propElemSize_const(instance: *const c_void) -> size_t;
		pub fn cv_MatConstIterator_propElemSize_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_MatConstIterator_propPtr_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_propSliceStart_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_propSliceEnd_const(instance: *const c_void) -> *const u8;
		pub fn cv_MatConstIterator_delete(instance: *mut c_void);
		pub fn cv_MatExpr_MatExpr(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatOpX_int_const_MatR_const_MatR_const_MatR_double_double_const_ScalarR(_op: *const c_void, _flags: i32, _a: *const c_void, _b: *const c_void, _c: *const c_void, _alpha: f64, _beta: f64, _s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_MatExpr_const_MatOpX_int(_op: *const c_void, _flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator_cv_Mat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatExpr_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatExpr_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_diag_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator___const_const_RangeR_const_RangeR(instance: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_inv_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatExprR_double(instance: *const c_void, e: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatExprR(instance: *const c_void, e: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_mul_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_cross_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MatExpr_dot_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MatExpr_swap_MatExprR(instance: *mut c_void, b: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatExpr_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_MatExpr_propFlags_const_int(instance: *mut c_void, val: i32);
		pub fn cv_MatExpr_propA_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_propA_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_MatExpr_propB_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_propB_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_MatExpr_propC_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_MatExpr_propC_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_MatExpr_propAlpha_const(instance: *const c_void) -> f64;
		pub fn cv_MatExpr_propAlpha_const_double(instance: *mut c_void, val: f64);
		pub fn cv_MatExpr_propBeta_const(instance: *const c_void) -> f64;
		pub fn cv_MatExpr_propBeta_const_double(instance: *mut c_void, val: f64);
		pub fn cv_MatExpr_propS_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_MatExpr_propS_const_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_MatExpr_delete(instance: *mut c_void);
		pub fn cv_MatOp_elementWise_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_MatOp_assign_const_const_MatExprR_MatR_int(instance: *const c_void, expr: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_assign_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_roi_const_const_MatExprR_const_RangeR_const_RangeR_MatExprR(instance: *const c_void, expr: *const c_void, row_range: *const c_void, col_range: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_diag_const_const_MatExprR_int_MatExprR(instance: *const c_void, expr: *const c_void, d: i32, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignAdd_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignSubtract_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignMultiply_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignDivide_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignAnd_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignOr_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_augAssignXor_const_const_MatExprR_MatR(instance: *const c_void, expr: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_add_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_add_const_const_MatExprR_const_ScalarR_MatExprR(instance: *const c_void, expr1: *const c_void, s: *const core::Scalar, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_subtract_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_subtract_const_const_ScalarR_const_MatExprR_MatExprR(instance: *const c_void, s: *const core::Scalar, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_multiply_const_const_MatExprR_const_MatExprR_MatExprR_double(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, scale: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_multiply_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_multiply_const_const_MatExprR_double_MatExprR(instance: *const c_void, expr1: *const c_void, s: f64, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_divide_const_const_MatExprR_const_MatExprR_MatExprR_double(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, scale: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_divide_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_divide_const_double_const_MatExprR_MatExprR(instance: *const c_void, s: f64, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_abs_const_const_MatExprR_MatExprR(instance: *const c_void, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_transpose_const_const_MatExprR_MatExprR(instance: *const c_void, expr: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_matmul_const_const_MatExprR_const_MatExprR_MatExprR(instance: *const c_void, expr1: *const c_void, expr2: *const c_void, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_invert_const_const_MatExprR_int_MatExprR(instance: *const c_void, expr: *const c_void, method: i32, res: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MatOp_size_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatOp_type_const_const_MatExprR(instance: *const c_void, expr: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatOp_delete(instance: *mut c_void);
		pub fn cv_MatSize_MatSize_intX(_p: *mut i32) -> *mut c_void;
		pub fn cv_MatSize_dims_const(instance: *const c_void) -> i32;
		pub fn cv_MatSize_operator___const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_MatSize_operator___const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_operator___int(instance: *mut c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_MatSize_operator_const_intX_const(instance: *const c_void) -> *const i32;
		pub fn cv_MatSize_operatorEQ_const_const_MatSizeR(instance: *const c_void, sz: *const c_void) -> bool;
		pub fn cv_MatSize_operatorNE_const_const_MatSizeR(instance: *const c_void, sz: *const c_void) -> bool;
		pub fn cv_MatSize_propP_const(instance: *const c_void) -> *const i32;
		pub fn cv_MatSize_propP(instance: *mut c_void) -> *mut i32;
		pub fn cv_MatSize_propP_intX(instance: *mut c_void, val: *const i32);
		pub fn cv_MatSize_delete(instance: *mut c_void);
		pub fn cv_MatStep_MatStep() -> *mut c_void;
		pub fn cv_MatStep_MatStep_size_t(s: size_t) -> *mut c_void;
		pub fn cv_MatStep_operator___const_int(instance: *const c_void, i: i32) -> size_t;
		pub fn cv_MatStep_operator___int(instance: *mut c_void, i: i32) -> size_t;
		pub fn cv_MatStep_operator_size_t_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_MatStep_operatorST_size_t(instance: *mut c_void, s: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_MatStep_propP_const(instance: *const c_void) -> *const size_t;
		pub fn cv_MatStep_propP(instance: *mut c_void) -> *mut size_t;
		pub fn cv_MatStep_propP_size_tX(instance: *mut c_void, val: *const size_t);
		pub fn cv_MatStep_propBuf_const(instance: *const c_void) -> *const [size_t; 2];
		pub fn cv_MatStep_propBuf(instance: *mut c_void) -> *mut [size_t; 2];
		pub fn cv_MatStep_delete(instance: *mut c_void);
		pub fn cv_Matx_AddOp_Matx_AddOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_AddOp_Matx_AddOp_const_Matx_AddOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_AddOp_delete(instance: *mut c_void);
		pub fn cv_Matx_DivOp_Matx_DivOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_DivOp_Matx_DivOp_const_Matx_DivOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_DivOp_delete(instance: *mut c_void);
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MatMulOp_Matx_MatMulOp_const_Matx_MatMulOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MatMulOp_delete(instance: *mut c_void);
		pub fn cv_Matx_MulOp_Matx_MulOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MulOp_Matx_MulOp_const_Matx_MulOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_MulOp_delete(instance: *mut c_void);
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_ScaleOp_Matx_ScaleOp_const_Matx_ScaleOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_ScaleOp_delete(instance: *mut c_void);
		pub fn cv_Matx_SubOp_Matx_SubOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_SubOp_Matx_SubOp_const_Matx_SubOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_SubOp_delete(instance: *mut c_void);
		pub fn cv_Matx_TOp_Matx_TOp(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_TOp_Matx_TOp_const_Matx_TOpR(unnamed: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Matx_TOp_delete(instance: *mut c_void);
		pub fn cv_MinProblemSolver_getFunction_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_MinProblemSolver_setFunction_const_PtrLFunctionGR(instance: *mut c_void, f: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_MinProblemSolver_getTermCriteria_const(instance: *const c_void, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_MinProblemSolver_setTermCriteria_const_TermCriteriaR(instance: *mut c_void, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<()>);
		pub fn cv_MinProblemSolver_minimize_const__InputOutputArrayR(instance: *mut c_void, x: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_to_ConjGradSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MinProblemSolver_to_DownhillSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MinProblemSolver_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_MinProblemSolver_delete(instance: *mut c_void);
		pub fn cv_MinProblemSolver_Function_getDims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_MinProblemSolver_Function_getGradientEps_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_calc_const_const_doubleX(instance: *const c_void, x: *const f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_MinProblemSolver_Function_getGradient_const_doubleX_doubleX(instance: *mut c_void, x: *const f64, grad: *mut f64, ocvrs_return: *mut Result<()>);
		pub fn cv_MinProblemSolver_Function_delete(instance: *mut c_void);
		pub fn cv_Moments_Moments(ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_Moments_Moments_double_double_double_double_double_double_double_double_double_double(m00: f64, m10: f64, m01: f64, m20: f64, m11: f64, m02: f64, m30: f64, m21: f64, m12: f64, m03: f64, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_PCA_PCA(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int_int(data: *const c_void, mean: *const c_void, flags: i32, max_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int(data: *const c_void, mean: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_PCA_const__InputArrayR_const__InputArrayR_int_double(data: *const c_void, mean: *const c_void, flags: i32, retained_variance: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int_int(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, max_components: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_operator___const__InputArrayR_const__InputArrayR_int_double(instance: *mut c_void, data: *const c_void, mean: *const c_void, flags: i32, retained_variance: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_project_const_const__InputArrayR(instance: *const c_void, vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_project_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, vec: *const c_void, result: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCA_backProject_const_const__InputArrayR(instance: *const c_void, vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_PCA_backProject_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, vec: *const c_void, result: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCA_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCA_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_PCA_propEigenvectors_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_propEigenvectors_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_PCA_propEigenvalues_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_propEigenvalues_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_PCA_propMean_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PCA_propMean_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_PCA_delete(instance: *mut c_void);
		pub fn cv_ParallelLoopBody_operator___const_const_RangeR(instance: *const c_void, range: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ParallelLoopBody_delete(instance: *mut c_void);
		pub fn cv_RNG_RNG(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_RNG_uint64_t(state: u64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_next(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator_unsigned_char(instance: *mut c_void, ocvrs_return: *mut Result<u8>);
		pub fn cv_RNG_operator_signed_char(instance: *mut c_void, ocvrs_return: *mut Result<i8>);
		pub fn cv_RNG_operator_unsigned_short(instance: *mut c_void, ocvrs_return: *mut Result<u16>);
		pub fn cv_RNG_operator_short(instance: *mut c_void, ocvrs_return: *mut Result<i16>);
		pub fn cv_RNG_operator_unsigned_int(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator_int(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_operator_float(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_operator_double(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_operator__(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_operator___unsigned_int(instance: *mut c_void, n: u32, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_uniform_int_int(instance: *mut c_void, a: i32, b: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_uniform_float_float(instance: *mut c_void, a: f32, b: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_uniform_double_double(instance: *mut c_void, a: f64, b: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_fill_const__InputOutputArrayR_int_const__InputArrayR_const__InputArrayR_bool(instance: *mut c_void, mat: *const c_void, dist_type: i32, a: *const c_void, b: *const c_void, saturate_range: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_RNG_fill_const__InputOutputArrayR_int_const__InputArrayR_const__InputArrayR(instance: *mut c_void, mat: *const c_void, dist_type: i32, a: *const c_void, b: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_RNG_gaussian_double(instance: *mut c_void, sigma: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_operatorEQ_const_const_RNGR(instance: *const c_void, other: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_RNG_propState_const(instance: *const c_void) -> u64;
		pub fn cv_RNG_propState_const_uint64_t(instance: *mut c_void, val: u64);
		pub fn cv_RNG_delete(instance: *mut c_void);
		pub fn cv_RNG_MT19937_RNG_MT19937(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_MT19937_RNG_MT19937_unsigned_int(s: u32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_RNG_MT19937_seed_unsigned_int(instance: *mut c_void, s: u32, ocvrs_return: *mut Result<()>);
		pub fn cv_RNG_MT19937_next(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator_int(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_MT19937_operator_unsigned_int(instance: *mut c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_operator_float(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_MT19937_operator_double(instance: *mut c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_MT19937_operator___unsigned_int(instance: *mut c_void, n: u32, ocvrs_return: *mut Result<u32>);
		pub fn cv_RNG_MT19937_uniform_int_int(instance: *mut c_void, a: i32, b: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_RNG_MT19937_uniform_float_float(instance: *mut c_void, a: f32, b: f32, ocvrs_return: *mut Result<f32>);
		pub fn cv_RNG_MT19937_uniform_double_double(instance: *mut c_void, a: f64, b: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_RNG_MT19937_delete(instance: *mut c_void);
		pub fn cv_Range_Range(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_Range_int_int(_start: i32, _end: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_size_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_Range_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Range_all(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Range_propStart_const(instance: *const c_void) -> i32;
		pub fn cv_Range_propStart_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Range_propEnd_const(instance: *const c_void) -> i32;
		pub fn cv_Range_propEnd_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Range_delete(instance: *mut c_void);
		pub fn cv_RotatedRect_RotatedRect(ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_RotatedRect_RotatedRect_const_Point2fR_const_Size2fR_float(center: *const core::Point2f, size: *const core::Size2f, angle: f32, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_RotatedRect_RotatedRect_const_Point2fR_const_Point2fR_const_Point2fR(point1: *const core::Point2f, point2: *const core::Point2f, point3: *const core::Point2f, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_RotatedRect_points_const_Point2fXX(instance: *const core::RotatedRect, pts: *mut [core::Point2f; 4], ocvrs_return: *mut Result<()>);
		pub fn cv_RotatedRect_points_const_vectorLPoint2fGR(instance: *const core::RotatedRect, pts: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_RotatedRect_boundingRect_const(instance: *const core::RotatedRect, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_RotatedRect_boundingRect2f_const(instance: *const core::RotatedRect, ocvrs_return: *mut Result<core::Rect2f>);
		pub fn cv_SVD_SVD(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_SVD_const__InputArrayR_int(src: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_SVD_const__InputArrayR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_operator___const__InputArrayR_int(instance: *mut c_void, src: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_operator___const__InputArrayR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, w: *const c_void, u: *const c_void, vt: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, w: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_compute_const__InputArrayR_const__OutputArrayR(src: *const c_void, w: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_backSubst_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(w: *const c_void, u: *const c_void, vt: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_solveZ_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_backSubst_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, rhs: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SVD_propU_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_propU_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_SVD_propW_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_propW_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_SVD_propVt_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SVD_propVt_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_SVD_delete(instance: *mut c_void);
		pub fn cv_SparseMat_SparseMat(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_int_const_intX_int(dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_const_SparseMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_SparseMat_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_operatorST_const_SparseMatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_operatorST_const_MatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_copyTo_const_SparseMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_copyTo_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_convertTo_const_SparseMatR_int_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_convertTo_const_SparseMatR_int(instance: *const c_void, m: *mut c_void, rtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_convertTo_const_MatR_int_double_double(instance: *const c_void, m: *mut c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_convertTo_const_MatR_int(instance: *const c_void, m: *mut c_void, rtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_assignTo_const_SparseMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_assignTo_const_SparseMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_create_int_const_intX_int(instance: *mut c_void, dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_clear(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_addref(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_release(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_elemSize_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_type_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<*const i32>);
		pub fn cv_SparseMat_size_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparseMat_dims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_SparseMat_nzcount_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int(instance: *const c_void, i0: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int_int(instance: *const c_void, i0: i32, i1: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_int_int_int(instance: *const c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_hash_const_const_intX(instance: *const c_void, idx: *const i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_SparseMat_ptr_int_bool_size_tX(instance: *mut c_void, i0: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_bool(instance: *mut c_void, i0: i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_bool(instance: *mut c_void, i0: i32, i1: i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_int_bool_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_int_int_int_bool(instance: *mut c_void, i0: i32, i1: i32, i2: i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_const_intX_bool_size_tX(instance: *mut c_void, idx: *const i32, create_missing: bool, hashval: *mut size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_ptr_const_intX_bool(instance: *mut c_void, idx: *const i32, create_missing: bool, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_erase_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, hashval: *mut size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_erase_int_int(instance: *mut c_void, i0: i32, i1: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_erase_int_int_int_size_tX(instance: *mut c_void, i0: i32, i1: i32, i2: i32, hashval: *mut size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_erase_int_int_int(instance: *mut c_void, i0: i32, i1: i32, i2: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_erase_const_intX_size_tX(instance: *mut c_void, idx: *const i32, hashval: *mut size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_erase_const_intX(instance: *mut c_void, idx: *const i32, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_begin(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_begin_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_end(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_end_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_node_size_t(instance: *mut c_void, nidx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_node_const_size_t(instance: *const c_void, nidx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_newNode_const_intX_size_t(instance: *mut c_void, idx: *const i32, hashval: size_t, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_SparseMat_removeNode_size_t_size_t_size_t(instance: *mut c_void, hidx: size_t, nidx: size_t, previdx: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_resizeHashTab_size_t(instance: *mut c_void, newsize: size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_propFlags_const_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_propHdr(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseMat_propHdr_HdrX(instance: *mut c_void, val: *const c_void);
		pub fn cv_SparseMat_delete(instance: *mut c_void);
		pub fn cv_SparseMat_Hdr_Hdr_int_const_intX_int(_dims: i32, _sizes: *const i32, _type: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMat_Hdr_clear(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMat_Hdr_propRefcount_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_propRefcount_const_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_propDims_const_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_propValueOffset_const(instance: *const c_void) -> i32;
		pub fn cv_SparseMat_Hdr_propValueOffset_const_int(instance: *mut c_void, val: i32);
		pub fn cv_SparseMat_Hdr_propNodeSize_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_propNodeSize_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_propNodeCount_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_propNodeCount_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_propFreeList_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Hdr_propFreeList_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Hdr_propPool_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMat_Hdr_propPool_const_vectorLunsigned_charG(instance: *mut c_void, val: *const c_void);
		pub fn cv_SparseMat_Hdr_propHashtab_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMat_Hdr_propHashtab_const_vectorLsize_tG(instance: *mut c_void, val: *const c_void);
		pub fn cv_SparseMat_Hdr_propSize_const(instance: *const c_void) -> *const [i32; 32];
		pub fn cv_SparseMat_Hdr_propSize(instance: *mut c_void) -> *mut [i32; 32];
		pub fn cv_SparseMat_Hdr_delete(instance: *mut c_void);
		pub fn cv_SparseMat_Node_defaultNew_const() -> *mut c_void;
		pub fn cv_SparseMat_Node_propHashval_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Node_propHashval_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Node_propNext_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMat_Node_propNext_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMat_Node_propIdx_const(instance: *const c_void) -> *const [i32; 32];
		pub fn cv_SparseMat_Node_propIdx(instance: *mut c_void) -> *mut [i32; 32];
		pub fn cv_SparseMat_Node_delete(instance: *mut c_void);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatX(_m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_SparseMatConstIterator_const_SparseMatConstIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_operatorST_const_SparseMatConstIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMatConstIterator_node_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatConstIterator_seekEnd(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMatConstIterator_propM_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_SparseMatConstIterator_propHashidx_const(instance: *const c_void) -> size_t;
		pub fn cv_SparseMatConstIterator_propHashidx_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_SparseMatConstIterator_propPtr_const(instance: *const c_void) -> *const u8;
		pub fn cv_SparseMatConstIterator_propPtr(instance: *mut c_void) -> *mut u8;
		pub fn cv_SparseMatConstIterator_propPtr_unsigned_charX(instance: *mut c_void, val: *const u8);
		pub fn cv_SparseMatConstIterator_delete(instance: *mut c_void);
		pub fn cv_SparseMatIterator_SparseMatIterator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_SparseMatIterator_SparseMatX(_m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_SparseMatIterator_const_SparseMatIteratorR(it: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_operatorST_const_SparseMatIteratorR(instance: *mut c_void, it: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_SparseMatIterator_node_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SparseMatIterator_to_SparseMatConstIterator(instance: *mut c_void) -> *mut c_void;
		pub fn cv_SparseMatIterator_delete(instance: *mut c_void);
		pub fn cv_TermCriteria_TermCriteria(ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_TermCriteria_TermCriteria_int_int_double(typ: i32, max_count: i32, epsilon: f64, ocvrs_return: *mut Result<core::TermCriteria>);
		pub fn cv_TermCriteria_isValid_const(instance: *const core::TermCriteria, ocvrs_return: *mut Result<bool>);
		pub fn cv_TickMeter_TickMeter(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_TickMeter_start(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_TickMeter_stop(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_TickMeter_getTimeTicks_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getTimeMicro_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getLastTimeTicks_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getLastTimeMicro_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getLastTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getLastTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getCounter_const(instance: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_TickMeter_getFPS_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getAvgTimeSec_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_getAvgTimeMilli_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_TickMeter_reset(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_TickMeter_delete(instance: *mut c_void);
		pub fn cv_UMat_UMat_UMatUsageFlags(usage_flags: core::UMatUsageFlags) -> *mut c_void;
		pub fn cv_UMat_UMat() -> *mut c_void;
		pub fn cv_UMat_UMat_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int_const_ScalarR_UMatUsageFlags(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_int_int_const_ScalarR(rows: i32, cols: i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_const_ScalarR_UMatUsageFlags(size: *const core::Size, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_Size_int_const_ScalarR(size: *const core::Size, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int(ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_const_ScalarR_UMatUsageFlags(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_int_const_intX_int_const_ScalarR(ndims: i32, sizes: *const i32, typ: i32, s: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RangeR_const_RangeR(m: *const c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_UMatR_const_RangeR(m: *mut c_void, row_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RangeR(m: *const c_void, row_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_UMatR_const_RangeR_const_RangeR(m: *mut c_void, row_range: *const c_void, col_range: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_RectR(m: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_UMatR_const_RectR(m: *mut c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_const_UMatR_const_vectorLRangeGR(m: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_UMat_UMatR_const_vectorLRangeGR(m: *mut c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operatorST_const_UMatR(instance: *mut c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_getMat_const_AccessFlag(instance: *const c_void, flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_row_const_int(instance: *const c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_row_int(instance: *mut c_void, y: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_col_const_int(instance: *const c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_col_int(instance: *mut c_void, x: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_int_int(instance: *const c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_int_int(instance: *mut c_void, startrow: i32, endrow: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_rowRange_const_RangeR(instance: *mut c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_int_int(instance: *const c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_int_int(instance: *mut c_void, startcol: i32, endcol: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_const_RangeR(instance: *const c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_colRange_const_RangeR(instance: *mut c_void, r: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_int(instance: *const c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_int(instance: *mut c_void, d: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_UMatR_UMatUsageFlags(d: *const c_void, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_diag_const_UMatR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_clone_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_copyTo_const_const__OutputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, m: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_convertTo_const_const__OutputArrayR_int_double_double(instance: *const c_void, m: *const c_void, rtype: i32, alpha: f64, beta: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_convertTo_const_const__OutputArrayR_int(instance: *const c_void, m: *const c_void, rtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_assignTo_const_UMatR_int(instance: *const c_void, m: *mut c_void, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_assignTo_const_UMatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_operatorST_const_ScalarR(instance: *mut c_void, s: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_setTo_const__InputArrayR_const__InputArrayR(instance: *mut c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_setTo_const__InputArrayR(instance: *mut c_void, value: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int_int(instance: *const c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_int(instance: *mut c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int(instance: *const c_void, cn: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_int_int(instance: *mut c_void, cn: i32, rows: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_const_int_int_const_intX(instance: *const c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_reshape_int_int_const_intX(instance: *mut c_void, cn: i32, newndims: i32, newsz: *const i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_t_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_inv_const_int(instance: *const c_void, method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_inv_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_mul_const_const__InputArrayR_double(instance: *const c_void, m: *const c_void, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_mul_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_dot_const_const__InputArrayR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_UMat_zeros_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_const_intX_int_UMatUsageFlags(ndims: i32, sz: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_zeros_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_const_intX_int_UMatUsageFlags(ndims: i32, sz: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ones_int_const_intX_int(ndims: i32, sz: *const i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_int_int_int_UMatUsageFlags(rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_Size_int_UMatUsageFlags(size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_int_int_int(rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_eye_Size_int(size: *const core::Size, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_create_int_int_int_UMatUsageFlags(instance: *mut c_void, rows: i32, cols: i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_int_int_int(instance: *mut c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_Size_int_UMatUsageFlags(instance: *mut c_void, size: *const core::Size, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_Size_int(instance: *mut c_void, size: *const core::Size, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_int_const_intX_int_UMatUsageFlags(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_int_const_intX_int(instance: *mut c_void, ndims: i32, sizes: *const i32, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_const_vectorLintGR_int_UMatUsageFlags(instance: *mut c_void, sizes: *const c_void, typ: i32, usage_flags: core::UMatUsageFlags, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_create_const_vectorLintGR_int(instance: *mut c_void, sizes: *const c_void, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_addref(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_release(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_deallocate(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_locateROI_const_SizeR_PointR(instance: *const c_void, whole_size: *mut core::Size, ofs: *mut core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_adjustROI_int_int_int_int(instance: *mut c_void, dtop: i32, dbottom: i32, dleft: i32, dright: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_Range_Range(instance: *const c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___Range_Range(instance: *mut c_void, row_range: *mut c_void, col_range: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_RectR(instance: *const c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_RectR(instance: *mut c_void, roi: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_const_vectorLRangeGR(instance: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operator___const_vectorLRangeGR(instance: *mut c_void, ranges: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_isContinuous_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_isSubmatrix_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_elemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_elemSize1_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_type_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_depth_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_channels_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_step1_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_step1_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_UMat_empty_const(instance: *const c_void) -> bool;
		pub fn cv_UMat_total_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_checkVector_const_int_int_bool(instance: *const c_void, elem_channels: i32, depth: i32, require_continuous: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_UMat_checkVector_const_int(instance: *const c_void, elem_channels: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_UMat_UMat_UMatRR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_operatorST_UMatRR(instance: *mut c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_handle_const_AccessFlag(instance: *const c_void, access_flags: core::AccessFlag, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_UMat_ndoffset_const_size_tX(instance: *const c_void, ofs: *mut size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_updateContinuityFlag(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMat_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_UMat_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propFlags_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propDims_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propDims_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propRows_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propRows_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propCols_const(instance: *const c_void) -> i32;
		pub fn cv_UMat_propCols_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMat_propUsageFlags_const(instance: *const c_void, ocvrs_return: *mut core::UMatUsageFlags);
		pub fn cv_UMat_propUsageFlags_const_UMatUsageFlags(instance: *mut c_void, val: core::UMatUsageFlags);
		pub fn cv_UMat_propU(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMat_propU_UMatDataX(instance: *mut c_void, val: *const c_void);
		pub fn cv_UMat_propOffset_const(instance: *const c_void) -> size_t;
		pub fn cv_UMat_propOffset_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_UMat_propSize_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_UMat_propSize_const_MatSize(instance: *mut c_void, val: *const c_void);
		pub fn cv_UMat_propStep_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_UMat_delete(instance: *mut c_void);
		pub fn cv_UMatData_lock(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMatData_unlock(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_UMatData_hostCopyObsolete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_deviceCopyObsolete_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_deviceMemMapped_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_copyOnMap_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_tempUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_tempCopiedUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_UMatData_markHostCopyObsolete_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_UMatData_markDeviceCopyObsolete_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_UMatData_markDeviceMemMapped_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_UMatData_propUrefcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propUrefcount_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propRefcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propRefcount_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propData_const(instance: *const c_void) -> *const u8;
		pub fn cv_UMatData_propData(instance: *mut c_void) -> *mut u8;
		pub fn cv_UMatData_propData_unsigned_charX(instance: *mut c_void, val: *const u8);
		pub fn cv_UMatData_propOrigdata_const(instance: *const c_void) -> *const u8;
		pub fn cv_UMatData_propOrigdata(instance: *mut c_void) -> *mut u8;
		pub fn cv_UMatData_propOrigdata_unsigned_charX(instance: *mut c_void, val: *const u8);
		pub fn cv_UMatData_propSize_const(instance: *const c_void) -> size_t;
		pub fn cv_UMatData_propSize_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_UMatData_propFlags_const(instance: *const c_void, ocvrs_return: *mut core::UMatData_MemoryFlag);
		pub fn cv_UMatData_propFlags_const_MemoryFlag(instance: *mut c_void, val: core::UMatData_MemoryFlag);
		pub fn cv_UMatData_propHandle(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_propHandle_voidX(instance: *mut c_void, val: *const c_void);
		pub fn cv_UMatData_propUserdata(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_propUserdata_voidX(instance: *mut c_void, val: *const c_void);
		pub fn cv_UMatData_propAllocatorFlags__const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propAllocatorFlags__const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propMapcount_const(instance: *const c_void) -> i32;
		pub fn cv_UMatData_propMapcount_const_int(instance: *mut c_void, val: i32);
		pub fn cv_UMatData_propOriginalUMatData(instance: *mut c_void) -> *mut c_void;
		pub fn cv_UMatData_propOriginalUMatData_UMatDataX(instance: *mut c_void, val: *const c_void);
		pub fn cv_UMatData_delete(instance: *mut c_void);
		pub fn cv__InputArray__InputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_MatExprR(expr: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLboolGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_doubleR(val: *const f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_UMatR(um: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray__InputArray_const_vectorLUMatGR(umv: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat__const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMat__const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getUMat_const_int(instance: *const c_void, idx: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getUMat_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getMatVector_const_vectorLMatGR(instance: *const c_void, mv: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__InputArray_getUMatVector_const_vectorLUMatGR(instance: *const c_void, umv: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__InputArray_getFlags_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_getObj_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_getSz_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_kind_const(instance: *const c_void, ocvrs_return: *mut Result<core::_InputArray_KindFlag>);
		pub fn cv__InputArray_dims_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_dims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_cols_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_cols_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_rows_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_rows_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_size_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_size_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv__InputArray_sizend_const_intX_int(instance: *const c_void, sz: *mut i32, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_sizend_const_intX(instance: *const c_void, sz: *mut i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_sameSize_const_const__InputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_total_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_total_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_type_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_depth_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_depth_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_channels_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_channels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv__InputArray_isContinuous_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isContinuous_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isSubmatrix_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isSubmatrix_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_copyTo_const_const__OutputArrayR(instance: *const c_void, arr: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__InputArray_copyTo_const_const__OutputArrayR_const__InputArrayR(instance: *const c_void, arr: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__InputArray_offset_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_offset_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_step_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_step_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv__InputArray_isMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isUMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isUMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isMatx_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isGpuMat_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray_isGpuMatVector_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__InputArray__InputArray_const_unsigned_charX_int(vec: *const u8, n: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputArray_delete(instance: *mut c_void);
		pub fn cv__InputOutputArray__InputOutputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_vectorLMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_UMatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_vectorLUMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray__InputOutputArray_const_vectorLUMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__InputOutputArray_to__InputArray(instance: *mut c_void) -> *mut c_void;
		pub fn cv__InputOutputArray_to__OutputArray(instance: *mut c_void) -> *mut c_void;
		pub fn cv__InputOutputArray_delete(instance: *mut c_void);
		pub fn cv__OutputArray__OutputArray(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_int_voidX(_flags: i32, _obj: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_MatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_UMatR(m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_vectorLUMatGR(vec: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_vectorLMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray__OutputArray_const_vectorLUMatGR(vec: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_fixedSize_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_fixedType_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_needed_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv__OutputArray_getMatRef_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getMatRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getUMatRef_const_int(instance: *const c_void, i: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_getUMatRef_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_create_const_Size_int_int_bool_DepthMask(instance: *const c_void, sz: *const core::Size, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_create_const_Size_int(instance: *const c_void, sz: *const core::Size, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_create_const_int_int_int_int_bool_DepthMask(instance: *const c_void, rows: i32, cols: i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_create_const_int_int_int(instance: *const c_void, rows: i32, cols: i32, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_create_const_int_const_intX_int_int_bool_DepthMask(instance: *const c_void, dims: i32, size: *const i32, typ: i32, i: i32, allow_transposed: bool, fixed_depth_mask: core::_OutputArray_DepthMask, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_create_const_int_const_intX_int(instance: *const c_void, dims: i32, size: *const i32, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_createSameSize_const_const__InputArrayR_int(instance: *const c_void, arr: *const c_void, mtype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_release_const(instance: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_clear_const(instance: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_setTo_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, value: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_setTo_const_const__InputArrayR(instance: *const c_void, value: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_reinterpret_const_int(instance: *const c_void, typ: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv__OutputArray_assign_const_const_UMatR(instance: *const c_void, u: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_assign_const_const_MatR(instance: *const c_void, m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_assign_const_const_vectorLUMatGR(instance: *const c_void, v: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_assign_const_const_vectorLMatGR(instance: *const c_void, v: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_move_const_UMatR(instance: *const c_void, u: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_move_const_MatR(instance: *const c_void, m: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv__OutputArray_to__InputArray(instance: *mut c_void) -> *mut c_void;
		pub fn cv__OutputArray_delete(instance: *mut c_void);
		pub fn cv_detail_CheckContext_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_defaultNew_const() -> *mut c_void;
		pub fn cv_detail_CheckContext_propFunc_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propFile_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propLine_const(instance: *const c_void) -> i32;
		pub fn cv_detail_CheckContext_propLine_const_int(instance: *mut c_void, val: i32);
		pub fn cv_detail_CheckContext_propTestOp_const(instance: *const c_void, ocvrs_return: *mut core::Detail_TestOp);
		pub fn cv_detail_CheckContext_propTestOp_const_TestOp(instance: *mut c_void, val: core::Detail_TestOp);
		pub fn cv_detail_CheckContext_propMessage_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propP1_str_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_propP2_str_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_detail_CheckContext_delete(instance: *mut c_void);
		pub fn cv_hfloat_hfloat(ocvrs_return: *mut Result<core::hfloat>);
		pub fn cv_hfloat_hfloat_float(x: f32, ocvrs_return: *mut Result<core::hfloat>);
		pub fn cv_hfloat_operator_float_const(instance: *const core::hfloat, ocvrs_return: *mut Result<f32>);
		pub fn cv_instr_NodeData_NodeData_const_charX_const_charX_int_voidX_bool_TYPE_IMPL(fun_name: *const c_char, file_name: *const c_char, line_num: i32, ret_address: *mut c_void, always_expand: bool, instr_type: core::TYPE, impl_type: core::IMPL, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_NodeData(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_NodeData_NodeDataR(ref_: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_instr_NodeData_operatorST_const_NodeDataR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_instr_NodeData_getTotalMs_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_instr_NodeData_getMeanMs_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_instr_NodeData_propM_funName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_propM_funName_const_String(instance: *mut c_void, val: *const c_char);
		pub fn cv_instr_NodeData_propM_instrType_const(instance: *const c_void, ocvrs_return: *mut core::TYPE);
		pub fn cv_instr_NodeData_propM_instrType_const_TYPE(instance: *mut c_void, val: core::TYPE);
		pub fn cv_instr_NodeData_propM_implType_const(instance: *const c_void, ocvrs_return: *mut core::IMPL);
		pub fn cv_instr_NodeData_propM_implType_const_IMPL(instance: *mut c_void, val: core::IMPL);
		pub fn cv_instr_NodeData_propM_fileName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_propM_lineNum_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_propM_lineNum_const_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_propM_retAddress(instance: *mut c_void) -> *mut c_void;
		pub fn cv_instr_NodeData_propM_retAddress_voidX(instance: *mut c_void, val: *const c_void);
		pub fn cv_instr_NodeData_propM_alwaysExpand_const(instance: *const c_void) -> bool;
		pub fn cv_instr_NodeData_propM_alwaysExpand_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_instr_NodeData_propM_funError_const(instance: *const c_void) -> bool;
		pub fn cv_instr_NodeData_propM_funError_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_instr_NodeData_propM_counter_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_propM_counter_const_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_propM_ticksTotal_const(instance: *const c_void) -> u64;
		pub fn cv_instr_NodeData_propM_ticksTotal_const_uint64_t(instance: *mut c_void, val: u64);
		pub fn cv_instr_NodeData_propM_threads_const(instance: *const c_void) -> i32;
		pub fn cv_instr_NodeData_propM_threads_const_int(instance: *mut c_void, val: i32);
		pub fn cv_instr_NodeData_delete(instance: *mut c_void);
		pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorageR_const_StringR_int_const_StringR(_fs: *mut c_void, name: *const c_char, flags: i32, type_name: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_internal_WriteStructContext_WriteStructContext_FileStorageR_const_StringR_int(_fs: *mut c_void, name: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_internal_WriteStructContext_delete(instance: *mut c_void);
		pub fn cv_ocl_Context_Context() -> *mut c_void;
		pub fn cv_ocl_Context_Context_int(dtype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_Context_const_ContextR(c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_operatorST_const_ContextR(instance: *mut c_void, c: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Context_Context_ContextRR(c: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Context_operatorST_ContextRR(instance: *mut c_void, c: *mut c_void);
		pub fn cv_ocl_Context_create(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_create_int(instance: *mut c_void, dtype: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_ndevices_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Context_device_const_size_t(instance: *const c_void, idx: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getProg_const_ProgramSourceR_const_StringR_StringR(instance: *mut c_void, prog: *const c_void, buildopt: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_unloadProg_ProgramR(instance: *mut c_void, prog: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Context_getDefault_bool(initialize: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_getOpenCLContextProperty_const_int(instance: *const c_void, property_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_useSVM_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_setUseSVM_bool(instance: *mut c_void, enabled: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Context_fromHandle_voidX(context: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_fromDevice_const_DeviceR(device: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_create_const_stringR(configuration: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Context_release(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Context_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Context_delete(instance: *mut c_void);
		pub fn cv_ocl_Context_UserContext_defaultNew_const() -> *mut c_void;
		pub fn cv_ocl_Context_UserContext_delete(instance: *mut c_void);
		pub fn cv_ocl_Device_Device() -> *mut c_void;
		pub fn cv_ocl_Device_Device_voidX(d: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_Device_const_DeviceR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_operatorST_const_DeviceR(instance: *mut c_void, d: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Device_Device_DeviceRR(d: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Device_operatorST_DeviceRR(instance: *mut c_void, d: *mut c_void);
		pub fn cv_ocl_Device_set_voidX(instance: *mut c_void, d: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Device_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_extensions_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_isExtensionSupported_const_const_StringR(instance: *const c_void, extension_name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_vendorName_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_OpenCL_C_Version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_OpenCLVersion_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_deviceVersionMajor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_deviceVersionMinor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_driverVersion_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_type_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_addressBits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_available_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_compilerAvailable_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_linkerAvailable_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_doubleFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_singleFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_halfFPConfig_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_hasFP64_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_hasFP16_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_endianLittle_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_errorCorrectionSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_executionCapabilities_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemCacheSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_globalMemCacheType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemCacheLineSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_globalMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_localMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_localMemType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_hostUnifiedMemory_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imageSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imageFromBufferSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_imagePitchAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ocl_Device_imageBaseAddressAlignment_const(instance: *const c_void, ocvrs_return: *mut Result<u32>);
		pub fn cv_ocl_Device_intelSubgroupsSupport_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_image2DMaxWidth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image2DMaxHeight_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxWidth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxHeight_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_image3DMaxDepth_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_imageMaxBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_imageMaxArraySize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_vendorID_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_isAMD_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_isIntel_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_isNVidia_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_maxClockFrequency_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxComputeUnits_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxConstantArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxConstantBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxMemAllocSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxParameterSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxReadImageArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWriteImageArgs_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxSamplers_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWorkGroupSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_maxWorkItemDims_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_maxWorkItemSizes_const_size_tX(instance: *const c_void, unnamed: *mut size_t, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Device_memBaseAddrAlign_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthChar_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthShort_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthInt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthLong_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthFloat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthDouble_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_nativeVectorWidthHalf_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthChar_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthShort_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthInt_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthLong_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthFloat_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthDouble_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_preferredVectorWidthHalf_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Device_printfBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_profilingTimerResolution_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Device_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_fromHandle_voidX(d: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Device_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Device_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_ocl_Device_delete(instance: *mut c_void);
		pub fn cv_ocl_Image2D_Image2D() -> *mut c_void;
		pub fn cv_ocl_Image2D_Image2D_const_UMatR_bool_bool(src: *const c_void, norm: bool, alias: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_Image2D_const_UMatR(src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_Image2D_const_Image2DR(i: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_operatorST_const_Image2DR(instance: *mut c_void, i: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Image2D_Image2D_Image2DRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Image2D_operatorST_Image2DRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_ocl_Image2D_canCreateAlias_const_UMatR(u: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_isFormatSupported_int_int_bool(depth: i32, cn: i32, norm: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Image2D_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Image2D_delete(instance: *mut c_void);
		pub fn cv_ocl_Kernel_Kernel() -> *mut c_void;
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramR(kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramSourceR_const_StringR_StringX(kname: *const c_char, prog: *const c_void, buildopts: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_charX_const_ProgramSourceR(kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_Kernel_const_KernelR(k: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_operatorST_const_KernelR(instance: *mut c_void, k: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Kernel_Kernel_KernelRR(k: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Kernel_operatorST_KernelRR(instance: *mut c_void, k: *mut c_void);
		pub fn cv_ocl_Kernel_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramR(instance: *mut c_void, kname: *const c_char, prog: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramSourceR_const_StringR_StringX(instance: *mut c_void, kname: *const c_char, prog: *const c_void, buildopts: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_create_const_charX_const_ProgramSourceR_const_StringR(instance: *mut c_void, kname: *const c_char, prog: *const c_void, buildopts: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_set_int_const_voidX_size_t(instance: *mut c_void, i: i32, value: *const c_void, sz: size_t, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_Image2DR(instance: *mut c_void, i: i32, image_2d: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_UMatR(instance: *mut c_void, i: i32, m: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_set_int_const_KernelArgR(instance: *mut c_void, i: i32, arg: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_Kernel_run_int_size_tX_size_tX_bool_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run_int_size_tX_size_tX_bool(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run__int_size_tX_size_tX_bool_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_run__int_size_tX_size_tX_bool(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, sync: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runTask_bool_const_QueueR(instance: *mut c_void, sync: bool, q: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runTask_bool(instance: *mut c_void, sync: bool, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_runProfiling_int_size_tX_size_tX_const_QueueR(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, q: *const c_void, ocvrs_return: *mut Result<i64>);
		pub fn cv_ocl_Kernel_runProfiling_int_size_tX_size_tX(instance: *mut c_void, dims: i32, globalsize: *mut size_t, localsize: *mut size_t, ocvrs_return: *mut Result<i64>);
		pub fn cv_ocl_Kernel_workGroupSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_preferedWorkGroupSizeMultiple_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_compileWorkGroupSize_const_size_tX(instance: *const c_void, wsz: *mut size_t, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Kernel_localMemSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ocl_Kernel_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Kernel_delete(instance: *mut c_void);
		pub fn cv_ocl_KernelArg_KernelArg_int_UMatX_int_int_const_voidX_size_t(_flags: i32, _m: *mut c_void, wscale: i32, iwscale: i32, _obj: *const c_void, _sz: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_KernelArg_int_UMatX(_flags: i32, _m: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_KernelArg() -> *mut c_void;
		pub fn cv_ocl_KernelArg_Local_size_t(local_mem_size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrWriteOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrReadOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_PtrReadWrite_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWrite_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWrite_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWriteNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadWriteNoSize_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnly_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnly_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnly_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnlyNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_ReadOnlyNoSize_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnlyNoSize_const_UMatR_int_int(m: *const c_void, wscale: i32, iwscale: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_WriteOnlyNoSize_const_UMatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_Constant_const_MatR(m: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_KernelArg_propFlags_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_propFlags_const_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_propM(instance: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_KernelArg_propM_UMatX(instance: *mut c_void, val: *const c_void);
		pub fn cv_ocl_KernelArg_propObj_const(instance: *const c_void) -> *const c_void;
		pub fn cv_ocl_KernelArg_propSz_const(instance: *const c_void) -> size_t;
		pub fn cv_ocl_KernelArg_propSz_const_size_t(instance: *mut c_void, val: size_t);
		pub fn cv_ocl_KernelArg_propWscale_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_propWscale_const_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_propIwscale_const(instance: *const c_void) -> i32;
		pub fn cv_ocl_KernelArg_propIwscale_const_int(instance: *mut c_void, val: i32);
		pub fn cv_ocl_KernelArg_delete(instance: *mut c_void);
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext() -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext_const_OpenCLExecutionContextR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_OpenCLExecutionContext_OpenCLExecutionContextRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_OpenCLExecutionContext_operatorST_const_OpenCLExecutionContextR(instance: *mut c_void, unnamed: *const c_void);
		pub fn cv_ocl_OpenCLExecutionContext_operatorST_OpenCLExecutionContextRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_ocl_OpenCLExecutionContext_getContext_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getDevice_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_useOpenCL_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_OpenCLExecutionContext_setUseOpenCL_bool(instance: *mut c_void, flag: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_OpenCLExecutionContext_getCurrent(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_getCurrentRef(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_bind_const(instance: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_OpenCLExecutionContext_cloneWithNewQueue_const_const_QueueR(instance: *const c_void, q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_cloneWithNewQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_stringR_voidX_voidX_voidX(platform_name: *const c_char, platform_id: *mut c_void, context: *mut c_void, device_id: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_ContextR_const_DeviceR_const_QueueR(context: *const c_void, device: *const c_void, queue: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_create_const_ContextR_const_DeviceR(context: *const c_void, device: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_OpenCLExecutionContext_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_OpenCLExecutionContext_release(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_OpenCLExecutionContext_delete(instance: *mut c_void);
		pub fn cv_ocl_Platform_Platform() -> *mut c_void;
		pub fn cv_ocl_Platform_Platform_const_PlatformR(p: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_operatorST_const_PlatformR(instance: *mut c_void, p: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Platform_Platform_PlatformRR(p: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Platform_operatorST_PlatformRR(instance: *mut c_void, p: *mut c_void);
		pub fn cv_ocl_Platform_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Platform_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Platform_delete(instance: *mut c_void);
		pub fn cv_ocl_PlatformInfo_PlatformInfo() -> *mut c_void;
		pub fn cv_ocl_PlatformInfo_PlatformInfo_voidX(id: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_PlatformInfo_const_PlatformInfoR(i: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_operatorST_const_PlatformInfoR(instance: *mut c_void, i: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_PlatformInfo_PlatformInfo_PlatformInfoRR(i: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_PlatformInfo_operatorST_PlatformInfoRR(instance: *mut c_void, i: *mut c_void);
		pub fn cv_ocl_PlatformInfo_name_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_vendor_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_version_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_PlatformInfo_versionMajor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_versionMinor_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_deviceNumber_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_ocl_PlatformInfo_getDevice_const_DeviceR_int(instance: *const c_void, device: *mut c_void, d: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_PlatformInfo_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_PlatformInfo_delete(instance: *mut c_void);
		pub fn cv_ocl_Program_Program() -> *mut c_void;
		pub fn cv_ocl_Program_Program_const_ProgramSourceR_const_StringR_StringR(src: *const c_void, buildflags: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_Program_const_ProgramR(prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_operatorST_const_ProgramR(instance: *mut c_void, prog: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Program_Program_ProgramRR(prog: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Program_operatorST_ProgramRR(instance: *mut c_void, prog: *mut c_void);
		pub fn cv_ocl_Program_create_const_ProgramSourceR_const_StringR_StringR(instance: *mut c_void, src: *const c_void, buildflags: *const c_char, errmsg: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getBinary_const_vectorLcharGR(instance: *const c_void, binary: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Program_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_read_const_StringR_const_StringR(instance: *mut c_void, buf: *const c_char, buildflags: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_write_const_StringR(instance: *const c_void, buf: *mut *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Program_source_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getPrefix_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_getPrefix_const_StringR(buildflags: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Program_delete(instance: *mut c_void);
		pub fn cv_ocl_ProgramSource_ProgramSource() -> *mut c_void;
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringR_const_StringR_const_StringR_const_StringR(module: *const c_char, name: *const c_char, code_str: *const c_char, code_hash: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_const_StringR(prog: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_ProgramSource_const_ProgramSourceR(prog: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_operatorST_const_ProgramSourceR(instance: *mut c_void, prog: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_ProgramSource_ProgramSource_ProgramSourceRR(prog: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_ProgramSource_operatorST_ProgramSourceRR(instance: *mut c_void, prog: *mut c_void);
		pub fn cv_ocl_ProgramSource_source_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_hash_const(instance: *const c_void, ocvrs_return: *mut Result<core::ProgramSource_hash_t>);
		pub fn cv_ocl_ProgramSource_fromBinary_const_StringR_const_StringR_const_unsigned_charX_const_size_t_const_StringR(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromBinary_const_StringR_const_StringR_const_unsigned_charX_const_size_t(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromSPIR_const_StringR_const_StringR_const_unsigned_charX_const_size_t_const_StringR(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, build_options: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_fromSPIR_const_StringR_const_StringR_const_unsigned_charX_const_size_t(module: *const c_char, name: *const c_char, binary: *const u8, size: size_t, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_ProgramSource_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_ProgramSource_delete(instance: *mut c_void);
		pub fn cv_ocl_Queue_Queue() -> *mut c_void;
		pub fn cv_ocl_Queue_Queue_const_ContextR_const_DeviceR(c: *const c_void, d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_Queue_const_ContextR(c: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_Queue_const_QueueR(q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_operatorST_const_QueueR(instance: *mut c_void, q: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Queue_Queue_QueueRR(q: *mut c_void) -> *mut c_void;
		pub fn cv_ocl_Queue_operatorST_QueueRR(instance: *mut c_void, q: *mut c_void);
		pub fn cv_ocl_Queue_create_const_ContextR_const_DeviceR(instance: *mut c_void, c: *const c_void, d: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_create(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_finish(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Queue_ptr_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_getDefault(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_getProfilingQueue_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Queue_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_ocl_Queue_delete(instance: *mut c_void);
		pub fn cv_ocl_Timer_Timer_const_QueueR(q: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ocl_Timer_start(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Timer_stop(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ocl_Timer_durationNS_const(instance: *const c_void, ocvrs_return: *mut Result<u64>);
		pub fn cv_ocl_Timer_delete(instance: *mut c_void);
		pub fn cv_utils_ClassWithKeywordProperties_ClassWithKeywordProperties_int_int(lambda_arg: i32, except_arg: i32, ocvrs_return: *mut Result<core::ClassWithKeywordProperties>);
		pub fn cv_utils_ClassWithKeywordProperties_ClassWithKeywordProperties(ocvrs_return: *mut Result<core::ClassWithKeywordProperties>);
		pub fn cv_utils_FunctionParams_setLambda_int(instance: *const core::FunctionParams, value: i32, ocvrs_return: *mut core::FunctionParams);
		pub fn cv_utils_FunctionParams_setSigma_float(instance: *const core::FunctionParams, value: f32, ocvrs_return: *mut core::FunctionParams);
		pub fn cv_utils_logging_LogTag_LogTag_const_charX_LogLevel(_name: *const c_char, _level: core::LogLevel, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_logging_LogTag_propName_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_utils_logging_LogTag_propLevel_const(instance: *const c_void, ocvrs_return: *mut core::LogLevel);
		pub fn cv_utils_logging_LogTag_propLevel_const_LogLevel(instance: *mut c_void, val: core::LogLevel);
		pub fn cv_utils_logging_LogTag_delete(instance: *mut c_void);
		pub fn cv_utils_nested_OriginalClassName_OriginalClassName_const_ParamsR(params: *const core::OriginalClassName_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_OriginalClassName(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_getIntParam_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_utils_nested_OriginalClassName_getFloatParam_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_utils_nested_OriginalClassName_originalName(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_create_const_ParamsR(params: *const core::OriginalClassName_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_utils_nested_OriginalClassName_delete(instance: *mut c_void);
		pub fn cv_utils_nested_OriginalClassName_Params_Params_int_float(int_param: i32, float_param: f32, ocvrs_return: *mut Result<core::OriginalClassName_Params>);
		pub fn cv_utils_nested_OriginalClassName_Params_Params(ocvrs_return: *mut Result<core::OriginalClassName_Params>);
		pub fn cv_PtrLcv_AlgorithmG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlgorithmG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_AlgorithmG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_AlgorithmG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_AlgorithmG_new_const_Algorithm(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_ConjGradSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_ConjGradSolverG_to_PtrOfMinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_DownhillSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DownhillSolverG_to_PtrOfMinProblemSolver(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_FileStorageG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FileStorageG_new_const_FileStorage(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_FormattedG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FormatterG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormatterG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FormatterG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_FormatterG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_KeyPointG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_KeyPointG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_KeyPointG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_KeyPointG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_KeyPointG_new_const_KeyPoint(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolverG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolverG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolverG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolverG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_MinProblemSolverG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_MinProblemSolver_FunctionG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_utils_nested_OriginalClassNameG_new_const_OriginalClassName(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLfloatG_getInnerPtr_const(instance: *const c_void) -> *const f32;
		pub fn cv_PtrLfloatG_getInnerPtrMut(instance: *mut c_void) -> *mut f32;
		pub fn cv_PtrLfloatG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLfloatG_delete(instance: *mut c_void);
		pub fn cv_PtrLfloatG_new_const_float(val: f32) -> *mut c_void;
		pub fn std_pairLcv_Rect__intG_new_const_Rect_int(arg: *const core::Rect, arg_1: i32) -> *mut c_void;
		pub fn std_pairLcv_Rect__intG_get_0_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn std_pairLcv_Rect__intG_get_1_const(instance: *const c_void, ocvrs_return: *mut i32);
		pub fn std_pairLcv_Rect__intG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DMatchG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DMatchG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DMatchG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DMatchG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DMatchG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DMatchG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DMatchG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DMatchG_push_const_DMatch(instance: *mut c_void, val: *const core::DMatch);
		pub fn std_vectorLcv_DMatchG_insert_size_t_const_DMatch(instance: *mut c_void, index: size_t, val: *const core::DMatch);
		pub fn std_vectorLcv_DMatchG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::DMatch);
		pub fn std_vectorLcv_DMatchG_set_size_t_const_DMatch(instance: *mut c_void, index: size_t, val: *const core::DMatch);
		pub fn std_vectorLcv_DMatchG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_DMatchG_data_const(instance: *const c_void) -> *const core::DMatch;
		pub fn std_vectorLcv_DMatchG_dataMut(instance: *mut c_void) -> *mut core::DMatch;
		pub fn cv_fromSlice_const_const_DMatchX_size_t(data: *const core::DMatch, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_KeyPointG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_KeyPointG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_KeyPointG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_KeyPointG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_KeyPointG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_KeyPointG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_KeyPointG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_KeyPointG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_KeyPointG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_KeyPointG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_KeyPointG_push_const_KeyPoint(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_KeyPointG_insert_size_t_const_KeyPoint(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_KeyPointG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_KeyPointG_set_size_t_const_KeyPoint(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_MatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_MatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_MatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_MatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_MatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_MatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_MatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_MatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_MatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_MatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_MatG_push_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_MatG_insert_size_t_const_Mat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_MatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_MatG_set_size_t_const_Mat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_ocl_PlatformInfoG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ocl_PlatformInfoG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_ocl_PlatformInfoG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_ocl_PlatformInfoG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_ocl_PlatformInfoG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_ocl_PlatformInfoG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_ocl_PlatformInfoG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_push_const_PlatformInfo(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_insert_size_t_const_PlatformInfo(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_ocl_PlatformInfoG_set_size_t_const_PlatformInfo(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_PointG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_PointG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_PointG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PointG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_PointG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_PointG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_PointG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_PointG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_PointG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_PointG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_PointG_push_const_Point(instance: *mut c_void, val: *const core::Point);
		pub fn std_vectorLcv_PointG_insert_size_t_const_Point(instance: *mut c_void, index: size_t, val: *const core::Point);
		pub fn std_vectorLcv_PointG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point);
		pub fn std_vectorLcv_PointG_set_size_t_const_Point(instance: *mut c_void, index: size_t, val: *const core::Point);
		pub fn std_vectorLcv_PointG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_PointG_data_const(instance: *const c_void) -> *const core::Point;
		pub fn std_vectorLcv_PointG_dataMut(instance: *mut c_void) -> *mut core::Point;
		pub fn cv_fromSlice_const_const_PointX_size_t(data: *const core::Point, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_PointG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_PointG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_PointG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point2dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point2dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point2dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point2dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point2dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point2dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point2dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point2dG_push_const_Point2d(instance: *mut c_void, val: *const core::Point2d);
		pub fn std_vectorLcv_Point2dG_insert_size_t_const_Point2d(instance: *mut c_void, index: size_t, val: *const core::Point2d);
		pub fn std_vectorLcv_Point2dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point2d);
		pub fn std_vectorLcv_Point2dG_set_size_t_const_Point2d(instance: *mut c_void, index: size_t, val: *const core::Point2d);
		pub fn std_vectorLcv_Point2dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point2dG_data_const(instance: *const c_void) -> *const core::Point2d;
		pub fn std_vectorLcv_Point2dG_dataMut(instance: *mut c_void) -> *mut core::Point2d;
		pub fn cv_fromSlice_const_const_Point2dX_size_t(data: *const core::Point2d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point2dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point2fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point2fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point2fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point2fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point2fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point2fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point2fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point2fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point2fG_push_const_Point2f(instance: *mut c_void, val: *const core::Point2f);
		pub fn std_vectorLcv_Point2fG_insert_size_t_const_Point2f(instance: *mut c_void, index: size_t, val: *const core::Point2f);
		pub fn std_vectorLcv_Point2fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point2f);
		pub fn std_vectorLcv_Point2fG_set_size_t_const_Point2f(instance: *mut c_void, index: size_t, val: *const core::Point2f);
		pub fn std_vectorLcv_Point2fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point2fG_data_const(instance: *const c_void) -> *const core::Point2f;
		pub fn std_vectorLcv_Point2fG_dataMut(instance: *mut c_void) -> *mut core::Point2f;
		pub fn cv_fromSlice_const_const_Point2fX_size_t(data: *const core::Point2f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point2fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point2fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Point3fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Point3fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Point3fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Point3fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Point3fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Point3fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Point3fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Point3fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Point3fG_push_const_Point3f(instance: *mut c_void, val: *const core::Point3f);
		pub fn std_vectorLcv_Point3fG_insert_size_t_const_Point3f(instance: *mut c_void, index: size_t, val: *const core::Point3f);
		pub fn std_vectorLcv_Point3fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Point3f);
		pub fn std_vectorLcv_Point3fG_set_size_t_const_Point3f(instance: *mut c_void, index: size_t, val: *const core::Point3f);
		pub fn std_vectorLcv_Point3fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Point3fG_data_const(instance: *const c_void) -> *const core::Point3f;
		pub fn std_vectorLcv_Point3fG_dataMut(instance: *mut c_void) -> *mut core::Point3f;
		pub fn cv_fromSlice_const_const_Point3fX_size_t(data: *const core::Point3f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Point3fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Point3fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RangeG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_RangeG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_RangeG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RangeG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_RangeG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RangeG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_RangeG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_RangeG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_RangeG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_RangeG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_RangeG_push_const_Range(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_RangeG_insert_size_t_const_Range(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_RangeG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_RangeG_set_size_t_const_Range(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_RectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_RectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_RectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_RectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_RectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_RectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_RectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_RectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_RectG_push_const_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn std_vectorLcv_RectG_insert_size_t_const_Rect(instance: *mut c_void, index: size_t, val: *const core::Rect);
		pub fn std_vectorLcv_RectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Rect);
		pub fn std_vectorLcv_RectG_set_size_t_const_Rect(instance: *mut c_void, index: size_t, val: *const core::Rect);
		pub fn std_vectorLcv_RectG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_RectG_data_const(instance: *const c_void) -> *const core::Rect;
		pub fn std_vectorLcv_RectG_dataMut(instance: *mut c_void) -> *mut core::Rect;
		pub fn cv_fromSlice_const_const_RectX_size_t(data: *const core::Rect, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_RectG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RectG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RectG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_RotatedRectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_RotatedRectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_RotatedRectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RotatedRectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_RotatedRectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_RotatedRectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_RotatedRectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_RotatedRectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_RotatedRectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_RotatedRectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_RotatedRectG_push_const_RotatedRect(instance: *mut c_void, val: *const core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_insert_size_t_const_RotatedRect(instance: *mut c_void, index: size_t, val: *const core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_set_size_t_const_RotatedRect(instance: *mut c_void, index: size_t, val: *const core::RotatedRect);
		pub fn std_vectorLcv_RotatedRectG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_RotatedRectG_data_const(instance: *const c_void) -> *const core::RotatedRect;
		pub fn std_vectorLcv_RotatedRectG_dataMut(instance: *mut c_void) -> *mut core::RotatedRect;
		pub fn cv_fromSlice_const_const_RotatedRectX_size_t(data: *const core::RotatedRect, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_StringG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_StringG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_StringG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_StringG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_StringG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_StringG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_StringG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_StringG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_StringG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_StringG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_StringG_push_const_String(instance: *mut c_void, val: *const c_char);
		pub fn std_vectorLcv_StringG_insert_size_t_const_String(instance: *mut c_void, index: size_t, val: *const c_char);
		pub fn std_vectorLcv_StringG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_StringG_set_size_t_const_String(instance: *mut c_void, index: size_t, val: *const c_char);
		pub fn std_vectorLcv_UMatG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_UMatG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_UMatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_UMatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_UMatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_UMatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_UMatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_UMatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_UMatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_UMatG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_UMatG_push_const_UMat(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_UMatG_insert_size_t_const_UMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_UMatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_UMatG_set_size_t_const_UMat(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_Vec2dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec2dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec2dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec2dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec2dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec2dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2dG_push_const_Vec2d(instance: *mut c_void, val: *const core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_insert_size_t_const_Vec2d(instance: *mut c_void, index: size_t, val: *const core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_set_size_t_const_Vec2d(instance: *mut c_void, index: size_t, val: *const core::Vec2d);
		pub fn std_vectorLcv_Vec2dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec2dG_data_const(instance: *const c_void) -> *const core::Vec2d;
		pub fn std_vectorLcv_Vec2dG_dataMut(instance: *mut c_void) -> *mut core::Vec2d;
		pub fn cv_fromSlice_const_const_Vec2dX_size_t(data: *const core::Vec2d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec2dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec2fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec2fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec2fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec2fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec2fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec2fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec2fG_push_const_Vec2f(instance: *mut c_void, val: *const core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_insert_size_t_const_Vec2f(instance: *mut c_void, index: size_t, val: *const core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_set_size_t_const_Vec2f(instance: *mut c_void, index: size_t, val: *const core::Vec2f);
		pub fn std_vectorLcv_Vec2fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec2fG_data_const(instance: *const c_void) -> *const core::Vec2f;
		pub fn std_vectorLcv_Vec2fG_dataMut(instance: *mut c_void) -> *mut core::Vec2f;
		pub fn cv_fromSlice_const_const_Vec2fX_size_t(data: *const core::Vec2f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec2fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec2fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3dG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec3dG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3dG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3dG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec3dG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3dG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3dG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec3dG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec3dG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec3dG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3dG_push_const_Vec3d(instance: *mut c_void, val: *const core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_insert_size_t_const_Vec3d(instance: *mut c_void, index: size_t, val: *const core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_set_size_t_const_Vec3d(instance: *mut c_void, index: size_t, val: *const core::Vec3d);
		pub fn std_vectorLcv_Vec3dG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec3dG_data_const(instance: *const c_void) -> *const core::Vec3d;
		pub fn std_vectorLcv_Vec3dG_dataMut(instance: *mut c_void) -> *mut core::Vec3d;
		pub fn cv_fromSlice_const_const_Vec3dX_size_t(data: *const core::Vec3d, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec3dG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3dG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3dG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec3fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec3fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec3fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec3fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec3fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec3fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec3fG_push_const_Vec3f(instance: *mut c_void, val: *const core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_insert_size_t_const_Vec3f(instance: *mut c_void, index: size_t, val: *const core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_set_size_t_const_Vec3f(instance: *mut c_void, index: size_t, val: *const core::Vec3f);
		pub fn std_vectorLcv_Vec3fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec3fG_data_const(instance: *const c_void) -> *const core::Vec3f;
		pub fn std_vectorLcv_Vec3fG_dataMut(instance: *mut c_void) -> *mut core::Vec3f;
		pub fn cv_fromSlice_const_const_Vec3fX_size_t(data: *const core::Vec3f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec3fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec3fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec4fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec4fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec4fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec4fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec4fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4fG_push_const_Vec4f(instance: *mut c_void, val: *const core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_insert_size_t_const_Vec4f(instance: *mut c_void, index: size_t, val: *const core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_set_size_t_const_Vec4f(instance: *mut c_void, index: size_t, val: *const core::Vec4f);
		pub fn std_vectorLcv_Vec4fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec4fG_data_const(instance: *const c_void) -> *const core::Vec4f;
		pub fn std_vectorLcv_Vec4fG_dataMut(instance: *mut c_void) -> *mut core::Vec4f;
		pub fn cv_fromSlice_const_const_Vec4fX_size_t(data: *const core::Vec4f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec4fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4iG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec4iG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4iG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4iG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec4iG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec4iG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4iG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec4iG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec4iG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec4iG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec4iG_push_const_Vec4i(instance: *mut c_void, val: *const core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_insert_size_t_const_Vec4i(instance: *mut c_void, index: size_t, val: *const core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_set_size_t_const_Vec4i(instance: *mut c_void, index: size_t, val: *const core::Vec4i);
		pub fn std_vectorLcv_Vec4iG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec4iG_data_const(instance: *const c_void) -> *const core::Vec4i;
		pub fn std_vectorLcv_Vec4iG_dataMut(instance: *mut c_void) -> *mut core::Vec4i;
		pub fn cv_fromSlice_const_const_Vec4iX_size_t(data: *const core::Vec4i, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec4iG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4iG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec4iG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec6fG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_Vec6fG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_Vec6fG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec6fG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_Vec6fG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_Vec6fG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_Vec6fG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_Vec6fG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_Vec6fG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_Vec6fG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_Vec6fG_push_const_Vec6f(instance: *mut c_void, val: *const core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_insert_size_t_const_Vec6f(instance: *mut c_void, index: size_t, val: *const core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_set_size_t_const_Vec6f(instance: *mut c_void, index: size_t, val: *const core::Vec6f);
		pub fn std_vectorLcv_Vec6fG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLcv_Vec6fG_data_const(instance: *const c_void) -> *const core::Vec6f;
		pub fn std_vectorLcv_Vec6fG_dataMut(instance: *mut c_void) -> *mut core::Vec6f;
		pub fn cv_fromSlice_const_const_Vec6fX_size_t(data: *const core::Vec6f, len: size_t) -> *mut c_void;
		pub fn std_vectorLcv_Vec6fG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec6fG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLcv_Vec6fG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_PointGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_PointGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_PointGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_PointGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_PointGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_PointGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_PointGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_PointGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_push_const_vectorLPointG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_insert_size_t_const_vectorLPointG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_set_size_t_const_vectorLPointG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_PointGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_PointGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_PointGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point2fGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_push_const_vectorLPoint2fG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_insert_size_t_const_vectorLPoint2fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_set_size_t_const_vectorLPoint2fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point2fGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLcv_Point3fGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_push_const_vectorLPoint3fG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_insert_size_t_const_vectorLPoint3fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_set_size_t_const_vectorLPoint3fG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLcv_Point3fGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLintGG_new_const() -> *mut c_void;
		pub fn std_vectorLstd_vectorLintGG_delete(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLintGG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLstd_vectorLintGG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLstd_vectorLintGG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLstd_vectorLintGG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLstd_vectorLintGG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLstd_vectorLintGG_clear(instance: *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_push_const_vectorLintG(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLstd_vectorLintGG_insert_size_t_const_vectorLintG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLintGG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLstd_vectorLintGG_set_size_t_const_vectorLintG(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLstd_vectorLintGG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLintGG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLstd_vectorLintGG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLboolG_new_const() -> *mut c_void;
		pub fn std_vectorLboolG_delete(instance: *mut c_void);
		pub fn std_vectorLboolG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLboolG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLboolG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLboolG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLboolG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLboolG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLboolG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLboolG_clear(instance: *mut c_void);
		pub fn std_vectorLboolG_push_const_bool(instance: *mut c_void, val: bool);
		pub fn std_vectorLboolG_insert_size_t_const_bool(instance: *mut c_void, index: size_t, val: bool);
		pub fn std_vectorLboolG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut bool);
		pub fn std_vectorLboolG_set_size_t_const_bool(instance: *mut c_void, index: size_t, val: bool);
		pub fn std_vectorLboolG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLfloatG_new_const() -> *mut c_void;
		pub fn std_vectorLfloatG_delete(instance: *mut c_void);
		pub fn std_vectorLfloatG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLfloatG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLfloatG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLfloatG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLfloatG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLfloatG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLfloatG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLfloatG_clear(instance: *mut c_void);
		pub fn std_vectorLfloatG_push_const_float(instance: *mut c_void, val: f32);
		pub fn std_vectorLfloatG_insert_size_t_const_float(instance: *mut c_void, index: size_t, val: f32);
		pub fn std_vectorLfloatG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut f32);
		pub fn std_vectorLfloatG_set_size_t_const_float(instance: *mut c_void, index: size_t, val: f32);
		pub fn std_vectorLfloatG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLfloatG_data_const(instance: *const c_void) -> *const f32;
		pub fn std_vectorLfloatG_dataMut(instance: *mut c_void) -> *mut f32;
		pub fn cv_fromSlice_const_const_floatX_size_t(data: *const f32, len: size_t) -> *mut c_void;
		pub fn std_vectorLfloatG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLfloatG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLfloatG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLdoubleG_new_const() -> *mut c_void;
		pub fn std_vectorLdoubleG_delete(instance: *mut c_void);
		pub fn std_vectorLdoubleG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLdoubleG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLdoubleG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLdoubleG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLdoubleG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLdoubleG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLdoubleG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLdoubleG_clear(instance: *mut c_void);
		pub fn std_vectorLdoubleG_push_const_double(instance: *mut c_void, val: f64);
		pub fn std_vectorLdoubleG_insert_size_t_const_double(instance: *mut c_void, index: size_t, val: f64);
		pub fn std_vectorLdoubleG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut f64);
		pub fn std_vectorLdoubleG_set_size_t_const_double(instance: *mut c_void, index: size_t, val: f64);
		pub fn std_vectorLdoubleG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLdoubleG_data_const(instance: *const c_void) -> *const f64;
		pub fn std_vectorLdoubleG_dataMut(instance: *mut c_void) -> *mut f64;
		pub fn cv_fromSlice_const_const_doubleX_size_t(data: *const f64, len: size_t) -> *mut c_void;
		pub fn std_vectorLdoubleG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLdoubleG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLdoubleG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLintG_new_const() -> *mut c_void;
		pub fn std_vectorLintG_delete(instance: *mut c_void);
		pub fn std_vectorLintG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLintG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLintG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLintG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLintG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLintG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLintG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLintG_clear(instance: *mut c_void);
		pub fn std_vectorLintG_push_const_int(instance: *mut c_void, val: i32);
		pub fn std_vectorLintG_insert_size_t_const_int(instance: *mut c_void, index: size_t, val: i32);
		pub fn std_vectorLintG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut i32);
		pub fn std_vectorLintG_set_size_t_const_int(instance: *mut c_void, index: size_t, val: i32);
		pub fn std_vectorLintG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLintG_data_const(instance: *const c_void) -> *const i32;
		pub fn std_vectorLintG_dataMut(instance: *mut c_void) -> *mut i32;
		pub fn cv_fromSlice_const_const_intX_size_t(data: *const i32, len: size_t) -> *mut c_void;
		pub fn std_vectorLintG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLintG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLintG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLsigned_charG_new_const() -> *mut c_void;
		pub fn std_vectorLsigned_charG_delete(instance: *mut c_void);
		pub fn std_vectorLsigned_charG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsigned_charG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLsigned_charG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsigned_charG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLsigned_charG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLsigned_charG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLsigned_charG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLsigned_charG_clear(instance: *mut c_void);
		pub fn std_vectorLsigned_charG_push_const_signed_char(instance: *mut c_void, val: i8);
		pub fn std_vectorLsigned_charG_insert_size_t_const_signed_char(instance: *mut c_void, index: size_t, val: i8);
		pub fn std_vectorLsigned_charG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut i8);
		pub fn std_vectorLsigned_charG_set_size_t_const_signed_char(instance: *mut c_void, index: size_t, val: i8);
		pub fn std_vectorLsigned_charG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLsigned_charG_data_const(instance: *const c_void) -> *const i8;
		pub fn std_vectorLsigned_charG_dataMut(instance: *mut c_void) -> *mut i8;
		pub fn cv_fromSlice_const_const_signed_charX_size_t(data: *const i8, len: size_t) -> *mut c_void;
		pub fn std_vectorLsize_tG_new_const() -> *mut c_void;
		pub fn std_vectorLsize_tG_delete(instance: *mut c_void);
		pub fn std_vectorLsize_tG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsize_tG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLsize_tG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLsize_tG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLsize_tG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLsize_tG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLsize_tG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLsize_tG_clear(instance: *mut c_void);
		pub fn std_vectorLsize_tG_push_const_size_t(instance: *mut c_void, val: size_t);
		pub fn std_vectorLsize_tG_insert_size_t_const_size_t(instance: *mut c_void, index: size_t, val: size_t);
		pub fn std_vectorLsize_tG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut size_t);
		pub fn std_vectorLsize_tG_set_size_t_const_size_t(instance: *mut c_void, index: size_t, val: size_t);
		pub fn std_vectorLsize_tG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLsize_tG_data_const(instance: *const c_void) -> *const size_t;
		pub fn std_vectorLsize_tG_dataMut(instance: *mut c_void) -> *mut size_t;
		pub fn cv_fromSlice_const_const_size_tX_size_t(data: *const size_t, len: size_t) -> *mut c_void;
		pub fn std_vectorLunsigned_charG_new_const() -> *mut c_void;
		pub fn std_vectorLunsigned_charG_delete(instance: *mut c_void);
		pub fn std_vectorLunsigned_charG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLunsigned_charG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLunsigned_charG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLunsigned_charG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLunsigned_charG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLunsigned_charG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLunsigned_charG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLunsigned_charG_clear(instance: *mut c_void);
		pub fn std_vectorLunsigned_charG_push_const_unsigned_char(instance: *mut c_void, val: u8);
		pub fn std_vectorLunsigned_charG_insert_size_t_const_unsigned_char(instance: *mut c_void, index: size_t, val: u8);
		pub fn std_vectorLunsigned_charG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut u8);
		pub fn std_vectorLunsigned_charG_set_size_t_const_unsigned_char(instance: *mut c_void, index: size_t, val: u8);
		pub fn std_vectorLunsigned_charG_clone_const(instance: *const c_void) -> *mut c_void;
		pub fn std_vectorLunsigned_charG_data_const(instance: *const c_void) -> *const u8;
		pub fn std_vectorLunsigned_charG_dataMut(instance: *mut c_void) -> *mut u8;
		pub fn cv_fromSlice_const_const_unsigned_charX_size_t(data: *const u8, len: size_t) -> *mut c_void;
		pub fn std_vectorLunsigned_charG_inputArray_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLunsigned_charG_outputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn std_vectorLunsigned_charG_inputOutputArray(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
	}
}
pub use core_sys::*;

mod highgui_sys {
	use super::*;

	extern "C" {
		pub fn cv_addText_const_MatR_const_StringR_Point_const_QtFontR(img: *const c_void, text: *const c_char, org: *const core::Point, font: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_addText_const_MatR_const_StringR_Point_const_StringR(img: *const c_void, text: *const c_char, org: *const core::Point, name_font: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_addText_const_MatR_const_StringR_Point_const_StringR_int_Scalar_int_int_int(img: *const c_void, text: *const c_char, org: *const core::Point, name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_createButton_const_StringR_ButtonCallback_voidX(bar_name: *const c_char, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_createButton_const_StringR_ButtonCallback_voidX_int_bool(bar_name: *const c_char, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, typ: i32, initial_button_state: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_createTrackbar_const_StringR_const_StringR_intX_int_TrackbarCallback_voidX(trackbarname: *const c_char, winname: *const c_char, value: *mut i32, count: i32, on_change: Option<unsafe extern "C" fn(i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_currentUIFramework(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_destroyAllWindows(ocvrs_return: *mut Result<()>);
		pub fn cv_destroyWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_displayOverlay_const_StringR_const_StringR(winname: *const c_char, text: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_displayOverlay_const_StringR_const_StringR_int(winname: *const c_char, text: *const c_char, delayms: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_displayStatusBar_const_StringR_const_StringR(winname: *const c_char, text: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_displayStatusBar_const_StringR_const_StringR_int(winname: *const c_char, text: *const c_char, delayms: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_fontQt_const_StringR(name_font: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_fontQt_const_StringR_int_Scalar_int_int_int(name_font: *const c_char, point_size: i32, color: *const core::Scalar, weight: i32, style: i32, spacing: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getMouseWheelDelta_int(flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getTrackbarPos_const_StringR_const_StringR(trackbarname: *const c_char, winname: *const c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_getWindowImageRect_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_getWindowProperty_const_StringR_int(winname: *const c_char, prop_id: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_imshow_const_StringR_const__InputArrayR(winname: *const c_char, mat: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_loadWindowParameters_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_moveWindow_const_StringR_int_int(winname: *const c_char, x: i32, y: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_namedWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_namedWindow_const_StringR_int(winname: *const c_char, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_pollKey(ocvrs_return: *mut Result<i32>);
		pub fn cv_resizeWindow_const_StringR_const_SizeR(winname: *const c_char, size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_resizeWindow_const_StringR_int_int(winname: *const c_char, width: i32, height: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_saveWindowParameters_const_StringR(window_name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_selectROI_const_StringR_const__InputArrayR(window_name: *const c_char, img: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const_StringR_const__InputArrayR_bool_bool_bool(window_name: *const c_char, img: *const c_void, show_crosshair: bool, from_center: bool, print_notice: bool, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const__InputArrayR(img: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROI_const__InputArrayR_bool_bool_bool(img: *const c_void, show_crosshair: bool, from_center: bool, print_notice: bool, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_selectROIs_const_StringR_const__InputArrayR_vectorLRectGR(window_name: *const c_char, img: *const c_void, bounding_boxes: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_selectROIs_const_StringR_const__InputArrayR_vectorLRectGR_bool_bool_bool(window_name: *const c_char, img: *const c_void, bounding_boxes: *mut c_void, show_crosshair: bool, from_center: bool, print_notice: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_setMouseCallback_const_StringR_MouseCallback_voidX(winname: *const c_char, on_mouse: Option<unsafe extern "C" fn(i32, i32, i32, i32, *mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_setOpenGlContext_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_setOpenGlDrawCallback_const_StringR_OpenGlDrawCallback_voidX(winname: *const c_char, on_opengl_draw: Option<unsafe extern "C" fn(*mut c_void) -> ()>, userdata: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_setTrackbarMax_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, maxval: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_setTrackbarMin_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, minval: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_setTrackbarPos_const_StringR_const_StringR_int(trackbarname: *const c_char, winname: *const c_char, pos: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_setWindowProperty_const_StringR_int_double(winname: *const c_char, prop_id: i32, prop_value: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_setWindowTitle_const_StringR_const_StringR(winname: *const c_char, title: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_startLoop_int__X__int__charXX__int_charXX(pt2_func: Option<unsafe extern "C" fn(i32, *mut *mut c_char) -> i32>, argc: i32, argv: *mut *mut c_char, ocvrs_return: *mut Result<i32>);
		pub fn cv_startWindowThread(ocvrs_return: *mut Result<i32>);
		pub fn cv_stopLoop(ocvrs_return: *mut Result<()>);
		pub fn cv_updateWindow_const_StringR(winname: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_waitKey(ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKeyEx(ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKeyEx_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_waitKey_int(delay: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_QtFont_defaultNew_const() -> *mut c_void;
		pub fn cv_QtFont_propNameFont_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QtFont_propColor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_QtFont_propColor_const_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_QtFont_propFont_face_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_propFont_face_const_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_propAscii_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_propGreek_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_propCyrillic_const(instance: *const c_void) -> *const i32;
		pub fn cv_QtFont_propHscale_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propHscale_const_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propVscale_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propVscale_const_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propShear_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propShear_const_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propThickness_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_propThickness_const_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_propDx_const(instance: *const c_void) -> f32;
		pub fn cv_QtFont_propDx_const_float(instance: *mut c_void, val: f32);
		pub fn cv_QtFont_propLine_type_const(instance: *const c_void) -> i32;
		pub fn cv_QtFont_propLine_type_const_int(instance: *mut c_void, val: i32);
		pub fn cv_QtFont_delete(instance: *mut c_void);
	}
}
pub use highgui_sys::*;

mod imgcodecs_sys {
	use super::*;

	extern "C" {
		pub fn cv_haveImageReader_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_haveImageWriter_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_imcount_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<size_t>);
		pub fn cv_imcount_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<size_t>);
		pub fn cv_imdecodeWithMetadata_const__InputArrayR_vectorLintGR_const__OutputArrayR(buf: *const c_void, metadata_types: *mut c_void, metadata: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecodeWithMetadata_const__InputArrayR_vectorLintGR_const__OutputArrayR_int(buf: *const c_void, metadata_types: *mut c_void, metadata: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecode_const__InputArrayR_int(buf: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecode_const__InputArrayR_int_MatX(buf: *const c_void, flags: i32, dst: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imdecodeanimation_const__InputArrayR_AnimationR(buf: *const c_void, animation: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imdecodeanimation_const__InputArrayR_AnimationR_int_int(buf: *const c_void, animation: *mut c_void, start: i32, count: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imdecodemulti_const__InputArrayR_int_vectorLMatGR(buf: *const c_void, flags: i32, mats: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imdecodemulti_const__InputArrayR_int_vectorLMatGR_const_RangeR(buf: *const c_void, flags: i32, mats: *mut c_void, range: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencodeWithMetadata_const_StringR_const__InputArrayR_const_vectorLintGR_const__InputArrayR_vectorLunsigned_charGR(ext: *const c_char, img: *const c_void, metadata_types: *const c_void, metadata: *const c_void, buf: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencodeWithMetadata_const_StringR_const__InputArrayR_const_vectorLintGR_const__InputArrayR_vectorLunsigned_charGR_const_vectorLintGR(ext: *const c_char, img: *const c_void, metadata_types: *const c_void, metadata: *const c_void, buf: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencode_const_StringR_const__InputArrayR_vectorLunsigned_charGR(ext: *const c_char, img: *const c_void, buf: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencode_const_StringR_const__InputArrayR_vectorLunsigned_charGR_const_vectorLintGR(ext: *const c_char, img: *const c_void, buf: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencodeanimation_const_StringR_const_AnimationR_vectorLunsigned_charGR(ext: *const c_char, animation: *const c_void, buf: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencodeanimation_const_StringR_const_AnimationR_vectorLunsigned_charGR_const_vectorLintGR(ext: *const c_char, animation: *const c_void, buf: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencodemulti_const_StringR_const__InputArrayR_vectorLunsigned_charGR(ext: *const c_char, imgs: *const c_void, buf: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imencodemulti_const_StringR_const__InputArrayR_vectorLunsigned_charGR_const_vectorLintGR(ext: *const c_char, imgs: *const c_void, buf: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadWithMetadata_const_StringR_vectorLintGR_const__OutputArrayR(filename: *const c_char, metadata_types: *mut c_void, metadata: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imreadWithMetadata_const_StringR_vectorLintGR_const__OutputArrayR_int(filename: *const c_char, metadata_types: *mut c_void, metadata: *const c_void, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imread_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imread_const_StringR_const__OutputArrayR(filename: *const c_char, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_imread_const_StringR_const__OutputArrayR_int(filename: *const c_char, dst: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_imread_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_imreadanimation_const_StringR_AnimationR(filename: *const c_char, animation: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadanimation_const_StringR_AnimationR_int_int(filename: *const c_char, animation: *mut c_void, start: i32, count: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR(filename: *const c_char, mats: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int(filename: *const c_char, mats: *mut c_void, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int_int(filename: *const c_char, mats: *mut c_void, start: i32, count: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imreadmulti_const_StringR_vectorLMatGR_int_int_int(filename: *const c_char, mats: *mut c_void, start: i32, count: i32, flags: i32, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwriteWithMetadata_const_StringR_const__InputArrayR_const_vectorLintGR_const__InputArrayR(filename: *const c_char, img: *const c_void, metadata_types: *const c_void, metadata: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwriteWithMetadata_const_StringR_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, metadata_types: *const c_void, metadata: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwrite_const_StringR_const__InputArrayR(filename: *const c_char, img: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwrite_const_StringR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwriteanimation_const_StringR_const_AnimationR(filename: *const c_char, animation: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwriteanimation_const_StringR_const_AnimationR_const_vectorLintGR(filename: *const c_char, animation: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwritemulti_const_StringR_const__InputArrayR(filename: *const c_char, img: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_imwritemulti_const_StringR_const__InputArrayR_const_vectorLintGR(filename: *const c_char, img: *const c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_Animation_Animation_int_Scalar(loop_count: i32, bg_color: *const core::Scalar, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Animation_Animation(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Animation_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Animation_propLoop_count_const(instance: *const c_void) -> i32;
		pub fn cv_Animation_propLoop_count_const_int(instance: *mut c_void, val: i32);
		pub fn cv_Animation_propBgcolor_const(instance: *const c_void, ocvrs_return: *mut core::Scalar);
		pub fn cv_Animation_propBgcolor_const_Scalar(instance: *mut c_void, val: *const core::Scalar);
		pub fn cv_Animation_propDurations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Animation_propDurations_const_vectorLintG(instance: *mut c_void, val: *const c_void);
		pub fn cv_Animation_propFrames_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Animation_propFrames_const_vectorLMatG(instance: *mut c_void, val: *const c_void);
		pub fn cv_Animation_propStill_image_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_Animation_propStill_image_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_Animation_delete(instance: *mut c_void);
		pub fn cv_ImageCollection_ImageCollection(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_ImageCollection_const_StringR_int(filename: *const c_char, flags: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_init_const_StringR_int(instance: *mut c_void, img: *const c_char, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ImageCollection_size_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_ImageCollection_at_int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_operator___int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_releaseCache_int(instance: *mut c_void, index: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ImageCollection_begin(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_end(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_delete(instance: *mut c_void);
		pub fn cv_ImageCollection_iterator_iterator_ImageCollectionX(col: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_iterator_ImageCollectionX_int(col: *mut c_void, end: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_operatorX(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_ImageCollection_iterator_delete(instance: *mut c_void);
	}
}
pub use imgcodecs_sys::*;

mod imgproc_sys {
	use super::*;

	extern "C" {
		pub fn cv_Canny_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double(dx: *const c_void, dy: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_Canny_const__InputArrayR_const__InputArrayR_const__OutputArrayR_double_double_bool(dx: *const c_void, dy: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, l2gradient: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_Canny_const__InputArrayR_const__OutputArrayR_double_double(image: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_Canny_const__InputArrayR_const__OutputArrayR_double_double_int_bool(image: *const c_void, edges: *const c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_EMD_const__InputArrayR_const__InputArrayR_int(signature1: *const c_void, signature2: *const c_void, dist_type: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_EMD_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_floatX_const__OutputArrayR(signature1: *const c_void, signature2: *const c_void, dist_type: i32, cost: *const c_void, lower_bound: *mut f32, flow: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_GaussianBlur_const__InputArrayR_const__OutputArrayR_Size_double(src: *const c_void, dst: *const c_void, ksize: *const core::Size, sigma_x: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GaussianBlur_const__InputArrayR_const__OutputArrayR_Size_double_double_int_AlgorithmHint(src: *const c_void, dst: *const c_void, ksize: *const core::Size, sigma_x: f64, sigma_y: f64, border_type: i32, hint: core::AlgorithmHint, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughCircles_const__InputArrayR_const__OutputArrayR_int_double_double(image: *const c_void, circles: *const c_void, method: i32, dp: f64, min_dist: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughCircles_const__InputArrayR_const__OutputArrayR_int_double_double_double_double_int_int(image: *const c_void, circles: *const c_void, method: i32, dp: f64, min_dist: f64, param1: f64, param2: f64, min_radius: i32, max_radius: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughLinesP_const__InputArrayR_const__OutputArrayR_double_double_int(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughLinesP_const__InputArrayR_const__OutputArrayR_double_double_int_double_double(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, min_line_length: f64, max_line_gap: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughLinesPointSet_const__InputArrayR_const__OutputArrayR_int_int_double_double_double_double_double_double(point: *const c_void, lines: *const c_void, lines_max: i32, threshold: i32, min_rho: f64, max_rho: f64, rho_step: f64, min_theta: f64, max_theta: f64, theta_step: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughLines_const__InputArrayR_const__OutputArrayR_double_double_int(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_HoughLines_const__InputArrayR_const__OutputArrayR_double_double_int_double_double_double_double_bool(image: *const c_void, lines: *const c_void, rho: f64, theta: f64, threshold: i32, srn: f64, stn: f64, min_theta: f64, max_theta: f64, use_edgeval: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_HuMoments_const_MomentsR_const__OutputArrayR(m: *const core::Moments, hu: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HuMoments_const_MomentsR_doubleXX(moments: *const core::Moments, hu: *mut [f64; 7], ocvrs_return: *mut Result<()>);
		pub fn cv_Laplacian_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ddepth: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Laplacian_const__InputArrayR_const__OutputArrayR_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Scharr_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Scharr_const__InputArrayR_const__OutputArrayR_int_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Sobel_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_Sobel_const__InputArrayR_const__OutputArrayR_int_int_int_int_double_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, dx: i32, dy: i32, ksize: i32, scale: f64, delta: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulateProduct_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulateProduct_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulateSquare_const__InputArrayR_const__InputOutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulateSquare_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulateWeighted_const__InputArrayR_const__InputOutputArrayR_double(src: *const c_void, dst: *const c_void, alpha: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulateWeighted_const__InputArrayR_const__InputOutputArrayR_double_const__InputArrayR(src: *const c_void, dst: *const c_void, alpha: f64, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulate_const__InputArrayR_const__InputOutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_accumulate_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_adaptiveThreshold_const__InputArrayR_const__OutputArrayR_double_int_int_int_double(src: *const c_void, dst: *const c_void, max_value: f64, adaptive_method: i32, threshold_type: i32, block_size: i32, c: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_applyColorMap_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, user_color: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_applyColorMap_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, colormap: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_approxPolyDP_const__InputArrayR_const__OutputArrayR_double_bool(curve: *const c_void, approx_curve: *const c_void, epsilon: f64, closed: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_approxPolyN_const__InputArrayR_const__OutputArrayR_int(curve: *const c_void, approx_curve: *const c_void, nsides: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_approxPolyN_const__InputArrayR_const__OutputArrayR_int_float_bool(curve: *const c_void, approx_curve: *const c_void, nsides: i32, epsilon_percentage: f32, ensure_convex: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_arcLength_const__InputArrayR_bool(curve: *const c_void, closed: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_arrowedLine_const__InputOutputArrayR_Point_Point_const_ScalarR(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_arrowedLine_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int_double(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, tip_length: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_double_double(src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_bilateralFilter_const__InputArrayR_const__OutputArrayR_int_double_double_int(src: *const c_void, dst: *const c_void, d: i32, sigma_color: f64, sigma_space: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_blendLinear_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(src1: *const c_void, src2: *const c_void, weights1: *const c_void, weights2: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_blur_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, ksize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_blur_const__InputArrayR_const__OutputArrayR_Size_Point_int(src: *const c_void, dst: *const c_void, ksize: *const core::Size, anchor: *const core::Point, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_boundingRect_const__InputArrayR(array: *const c_void, ocvrs_return: *mut Result<core::Rect>);
		pub fn cv_boxFilter_const__InputArrayR_const__OutputArrayR_int_Size(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_boxFilter_const__InputArrayR_const__OutputArrayR_int_Size_Point_bool_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_boxPoints_RotatedRect_const__OutputArrayR(box_: *const core::RotatedRect, points: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_buildPyramid_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, maxlevel: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_buildPyramid_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, maxlevel: i32, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_calcBackProject_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLfloatGR_double(images: *const c_void, channels: *const c_void, hist: *const c_void, dst: *const c_void, ranges: *const c_void, scale: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_calcHist_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLintGR_const_vectorLfloatGR(images: *const c_void, channels: *const c_void, mask: *const c_void, hist: *const c_void, hist_size: *const c_void, ranges: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_calcHist_const__InputArrayR_const_vectorLintGR_const__InputArrayR_const__OutputArrayR_const_vectorLintGR_const_vectorLfloatGR_bool(images: *const c_void, channels: *const c_void, mask: *const c_void, hist: *const c_void, hist_size: *const c_void, ranges: *const c_void, accumulate: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_circle_const__InputOutputArrayR_Point_int_const_ScalarR(img: *const c_void, center: *const core::Point, radius: i32, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_circle_const__InputOutputArrayR_Point_int_const_ScalarR_int_int_int(img: *const c_void, center: *const core::Point, radius: i32, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_clipLine_Rect_PointR_PointR(img_rect: *const core::Rect, pt1: *mut core::Point, pt2: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_clipLine_Size2l_Point2lR_Point2lR(img_size: *const core::Size2l, pt1: *mut core::Point2l, pt2: *mut core::Point2l, ocvrs_return: *mut Result<bool>);
		pub fn cv_clipLine_Size_PointR_PointR(img_size: *const core::Size, pt1: *mut core::Point, pt2: *mut core::Point, ocvrs_return: *mut Result<bool>);
		pub fn cv_compareHist_const_SparseMatR_const_SparseMatR_int(h1: *const c_void, h2: *const c_void, method: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_compareHist_const__InputArrayR_const__InputArrayR_int(h1: *const c_void, h2: *const c_void, method: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponentsWithStats_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, labels: *const c_void, stats: *const c_void, centroids: *const c_void, connectivity: i32, ltype: i32, ccltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR(image: *const c_void, labels: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_connectedComponents_const__InputArrayR_const__OutputArrayR_int_int_int(image: *const c_void, labels: *const c_void, connectivity: i32, ltype: i32, ccltype: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_contourArea_const__InputArrayR(contour: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_contourArea_const__InputArrayR_bool(contour: *const c_void, oriented: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_convertMaps_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int(map1: *const c_void, map2: *const c_void, dstmap1: *const c_void, dstmap2: *const c_void, dstmap1type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_convertMaps_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_bool(map1: *const c_void, map2: *const c_void, dstmap1: *const c_void, dstmap2: *const c_void, dstmap1type: i32, nninterpolation: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_convexHull_const__InputArrayR_const__OutputArrayR(points: *const c_void, hull: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_convexHull_const__InputArrayR_const__OutputArrayR_bool_bool(points: *const c_void, hull: *const c_void, clockwise: bool, return_points: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_convexityDefects_const__InputArrayR_const__InputArrayR_const__OutputArrayR(contour: *const c_void, convexhull: *const c_void, convexity_defects: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerEigenValsAndVecs_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerEigenValsAndVecs_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerHarris_const__InputArrayR_const__OutputArrayR_int_int_double(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, k: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerHarris_const__InputArrayR_const__OutputArrayR_int_int_double_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, k: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerMinEigenVal_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, block_size: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerMinEigenVal_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, block_size: i32, ksize: i32, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cornerSubPix_const__InputArrayR_const__InputOutputArrayR_Size_Size_TermCriteria(image: *const c_void, corners: *const c_void, win_size: *const core::Size, zero_zone: *const core::Size, criteria: *const core::TermCriteria, ocvrs_return: *mut Result<()>);
		pub fn cv_createCLAHE(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createCLAHE_double_Size(clip_limit: f64, tile_grid_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createGeneralizedHoughBallard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createGeneralizedHoughGuil(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createHanningWindow_const__OutputArrayR_Size_int(dst: *const c_void, win_size: *const core::Size, typ: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_createLineSegmentDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createLineSegmentDetector_int_double_double_double_double_double_double_int(refine: i32, scale: f64, sigma_scale: f64, quant: f64, ang_th: f64, log_eps: f64, density_th: f64, n_bins: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_cvtColorTwoPlane_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(src1: *const c_void, src2: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cvtColorTwoPlane_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_AlgorithmHint(src1: *const c_void, src2: *const c_void, dst: *const c_void, code: i32, hint: core::AlgorithmHint, ocvrs_return: *mut Result<()>);
		pub fn cv_cvtColor_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_cvtColor_const__InputArrayR_const__OutputArrayR_int_int_AlgorithmHint(src: *const c_void, dst: *const c_void, code: i32, dst_cn: i32, hint: core::AlgorithmHint, ocvrs_return: *mut Result<()>);
		pub fn cv_demosaicing_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, code: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_demosaicing_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, code: i32, dst_cn: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, kernel: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_dilate_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, labels: *const c_void, distance_type: i32, mask_size: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, labels: *const c_void, distance_type: i32, mask_size: i32, label_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, distance_type: i32, mask_size: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_distanceTransform_const__InputArrayR_const__OutputArrayR_int_int_int(src: *const c_void, dst: *const c_void, distance_type: i32, mask_size: i32, dst_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_divSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_divSpectrums_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_bool(a: *const c_void, b: *const c_void, c: *const c_void, flags: i32, conj_b: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_drawContours_const__InputOutputArrayR_const__InputArrayR_int_const_ScalarR(image: *const c_void, contours: *const c_void, contour_idx: i32, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_drawContours_const__InputOutputArrayR_const__InputArrayR_int_const_ScalarR_int_int_const__InputArrayR_int_Point(image: *const c_void, contours: *const c_void, contour_idx: i32, color: *const core::Scalar, thickness: i32, line_type: i32, hierarchy: *const c_void, max_level: i32, offset: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_drawMarker_const__InputOutputArrayR_Point_const_ScalarR(img: *const c_void, position: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_drawMarker_const__InputOutputArrayR_Point_const_ScalarR_int_int_int_int(img: *const c_void, position: *const core::Point, color: *const core::Scalar, marker_type: i32, marker_size: i32, thickness: i32, line_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ellipse2Poly_Point2d_Size2d_int_int_int_int_vectorLPoint2dGR(center: *const core::Point2d, axes: *const core::Size2d, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ellipse2Poly_Point_Size_int_int_int_int_vectorLPointGR(center: *const core::Point, axes: *const core::Size, angle: i32, arc_start: i32, arc_end: i32, delta: i32, pts: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_ellipse_const__InputOutputArrayR_Point_Size_double_double_double_const_ScalarR(img: *const c_void, center: *const core::Point, axes: *const core::Size, angle: f64, start_angle: f64, end_angle: f64, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_ellipse_const__InputOutputArrayR_Point_Size_double_double_double_const_ScalarR_int_int_int(img: *const c_void, center: *const core::Point, axes: *const core::Size, angle: f64, start_angle: f64, end_angle: f64, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_ellipse_const__InputOutputArrayR_const_RotatedRectR_const_ScalarR(img: *const c_void, box_: *const core::RotatedRect, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_ellipse_const__InputOutputArrayR_const_RotatedRectR_const_ScalarR_int_int(img: *const c_void, box_: *const core::RotatedRect, color: *const core::Scalar, thickness: i32, line_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_equalizeHist_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, kernel: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_erode_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_fillConvexPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR(img: *const c_void, points: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_fillConvexPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR_int_int(img: *const c_void, points: *const c_void, color: *const core::Scalar, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_fillPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR(img: *const c_void, pts: *const c_void, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_fillPoly_const__InputOutputArrayR_const__InputArrayR_const_ScalarR_int_int_Point(img: *const c_void, pts: *const c_void, color: *const core::Scalar, line_type: i32, shift: i32, offset: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_filter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(src: *const c_void, dst: *const c_void, ddepth: i32, kernel: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_filter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_Point_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, kernel: *const c_void, anchor: *const core::Point, delta: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_findContoursLinkRuns_const__InputArrayR_const__OutputArrayR(image: *const c_void, contours: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_findContoursLinkRuns_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(image: *const c_void, contours: *const c_void, hierarchy: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(image: *const c_void, contours: *const c_void, hierarchy: *const c_void, mode: i32, method: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int_Point(image: *const c_void, contours: *const c_void, hierarchy: *const c_void, mode: i32, method: i32, offset: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_int_int(image: *const c_void, contours: *const c_void, mode: i32, method: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_findContours_const__InputArrayR_const__OutputArrayR_int_int_Point(image: *const c_void, contours: *const c_void, mode: i32, method: i32, offset: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_fitEllipseAMS_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_fitEllipseDirect_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_fitEllipse_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_fitLine_const__InputArrayR_const__OutputArrayR_int_double_double_double(points: *const c_void, line: *const c_void, dist_type: i32, param: f64, reps: f64, aeps: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_floodFill_const__InputOutputArrayR_Point_Scalar(image: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_Point_Scalar_RectX_Scalar_Scalar_int(image: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_const__InputOutputArrayR_Point_Scalar(image: *const c_void, mask: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, ocvrs_return: *mut Result<i32>);
		pub fn cv_floodFill_const__InputOutputArrayR_const__InputOutputArrayR_Point_Scalar_RectX_Scalar_Scalar_int(image: *const c_void, mask: *const c_void, seed_point: *const core::Point, new_val: *const core::Scalar, rect: *mut core::Rect, lo_diff: *const core::Scalar, up_diff: *const core::Scalar, flags: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_getAffineTransform_const_Point2fXX_const_Point2fXX(src: *const [core::Point2f; 3], dst: *const [core::Point2f; 3], ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getAffineTransform_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getClosestEllipsePoints_const_RotatedRectR_const__InputArrayR_const__OutputArrayR(ellipse_params: *const core::RotatedRect, points: *const c_void, closest_pts: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_getDerivKernels_const__OutputArrayR_const__OutputArrayR_int_int_int(kx: *const c_void, ky: *const c_void, dx: i32, dy: i32, ksize: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_getDerivKernels_const__OutputArrayR_const__OutputArrayR_int_int_int_bool_int(kx: *const c_void, ky: *const c_void, dx: i32, dy: i32, ksize: i32, normalize: bool, ktype: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_getFontScaleFromHeight_const_int_const_int(font_face: i32, pixel_height: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_getFontScaleFromHeight_const_int_const_int_const_int(font_face: i32, pixel_height: i32, thickness: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_getGaborKernel_Size_double_double_double_double(ksize: *const core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaborKernel_Size_double_double_double_double_double_int(ksize: *const core::Size, sigma: f64, theta: f64, lambd: f64, gamma: f64, psi: f64, ktype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaussianKernel_int_double(ksize: i32, sigma: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getGaussianKernel_int_double_int(ksize: i32, sigma: f64, ktype: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const_Point2fXX_const_Point2fXX(src: *const [core::Point2f; 4], dst: *const [core::Point2f; 4], ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const_Point2fXX_const_Point2fXX_int(src: *const [core::Point2f; 4], dst: *const [core::Point2f; 4], solve_method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getPerspectiveTransform_const__InputArrayR_const__InputArrayR_int(src: *const c_void, dst: *const c_void, solve_method: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getRectSubPix_const__InputArrayR_Size_Point2f_const__OutputArrayR(image: *const c_void, patch_size: *const core::Size, center: *const core::Point2f, patch: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_getRectSubPix_const__InputArrayR_Size_Point2f_const__OutputArrayR_int(image: *const c_void, patch_size: *const core::Size, center: *const core::Point2f, patch: *const c_void, patch_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_getRotationMatrix2D_Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64, ocvrs_return: *mut Result<*mut c_void>);
		#[cfg(not(target_os = "windows"))]
		pub fn cv_getRotationMatrix2D__Point2f_double_double(center: *const core::Point2f, angle: f64, scale: f64, ocvrs_return: *mut Result<core::Matx23d>);
		pub fn cv_getStructuringElement_int_Size(shape: i32, ksize: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getStructuringElement_int_Size_Point(shape: i32, ksize: *const core::Size, anchor: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_getTextSize_const_StringR_int_double_int_intX(text: *const c_char, font_face: i32, font_scale: f64, thickness: i32, base_line: *mut i32, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_const__OutputArrayR(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, corners_quality: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_const__OutputArrayR_int_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, corners_quality: *const c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_int(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, gradient_size: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_goodFeaturesToTrack_const__InputArrayR_const__OutputArrayR_int_double_double_const__InputArrayR_int_int_bool_double(image: *const c_void, corners: *const c_void, max_corners: i32, quality_level: f64, min_distance: f64, mask: *const c_void, block_size: i32, gradient_size: i32, use_harris_detector: bool, k: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_grabCut_const__InputArrayR_const__InputOutputArrayR_Rect_const__InputOutputArrayR_const__InputOutputArrayR_int(img: *const c_void, mask: *const c_void, rect: *const core::Rect, bgd_model: *const c_void, fgd_model: *const c_void, iter_count: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_grabCut_const__InputArrayR_const__InputOutputArrayR_Rect_const__InputOutputArrayR_const__InputOutputArrayR_int_int(img: *const c_void, mask: *const c_void, rect: *const core::Rect, bgd_model: *const c_void, fgd_model: *const c_void, iter_count: i32, mode: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, sqsum: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, sum: *const c_void, sqsum: *const c_void, tilted: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, sum: *const c_void, sqsum: *const c_void, tilted: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, sum: *const c_void, sqsum: *const c_void, sdepth: i32, sqdepth: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_integral_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, sum: *const c_void, sdepth: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_intersectConvexConvex_const__InputArrayR_const__InputArrayR_const__OutputArrayR(p1: *const c_void, p2: *const c_void, p12: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_intersectConvexConvex_const__InputArrayR_const__InputArrayR_const__OutputArrayR_bool(p1: *const c_void, p2: *const c_void, p12: *const c_void, handle_nested: bool, ocvrs_return: *mut Result<f32>);
		pub fn cv_invertAffineTransform_const__InputArrayR_const__OutputArrayR(m: *const c_void, i_m: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_isContourConvex_const__InputArrayR(contour: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_line_const__InputOutputArrayR_Point_Point_const_ScalarR(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_line_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_linearPolar_const__InputArrayR_const__OutputArrayR_Point2f_double_int(src: *const c_void, dst: *const c_void, center: *const core::Point2f, max_radius: f64, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_logPolar_const__InputArrayR_const__OutputArrayR_Point2f_double_int(src: *const c_void, dst: *const c_void, center: *const core::Point2f, m: f64, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_matchShapes_const__InputArrayR_const__InputArrayR_int_double(contour1: *const c_void, contour2: *const c_void, method: i32, parameter: f64, ocvrs_return: *mut Result<f64>);
		pub fn cv_matchTemplate_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int(image: *const c_void, templ: *const c_void, result: *const c_void, method: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_matchTemplate_const__InputArrayR_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(image: *const c_void, templ: *const c_void, result: *const c_void, method: i32, mask: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_medianBlur_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ksize: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_minAreaRect_const__InputArrayR(points: *const c_void, ocvrs_return: *mut Result<core::RotatedRect>);
		pub fn cv_minEnclosingCircle_const__InputArrayR_Point2fR_floatR(points: *const c_void, center: *mut core::Point2f, radius: *mut f32, ocvrs_return: *mut Result<()>);
		pub fn cv_minEnclosingTriangle_const__InputArrayR_const__OutputArrayR(points: *const c_void, triangle: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_moments_const__InputArrayR(array: *const c_void, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_moments_const__InputArrayR_bool(array: *const c_void, binary_image: bool, ocvrs_return: *mut Result<core::Moments>);
		pub fn cv_morphologyDefaultBorderValue(ocvrs_return: *mut Result<core::Scalar>);
		pub fn cv_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR(src: *const c_void, dst: *const c_void, op: i32, kernel: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_morphologyEx_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_Point_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, op: i32, kernel: *const c_void, anchor: *const core::Point, iterations: i32, border_type: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_phaseCorrelate_const__InputArrayR_const__InputArrayR(src1: *const c_void, src2: *const c_void, ocvrs_return: *mut Result<core::Point2d>);
		pub fn cv_phaseCorrelate_const__InputArrayR_const__InputArrayR_const__InputArrayR_doubleX(src1: *const c_void, src2: *const c_void, window: *const c_void, response: *mut f64, ocvrs_return: *mut Result<core::Point2d>);
		pub fn cv_pointPolygonTest_const__InputArrayR_Point2f_bool(contour: *const c_void, pt: *const core::Point2f, measure_dist: bool, ocvrs_return: *mut Result<f64>);
		pub fn cv_polylines_const__InputOutputArrayR_const__InputArrayR_bool_const_ScalarR(img: *const c_void, pts: *const c_void, is_closed: bool, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_polylines_const__InputOutputArrayR_const__InputArrayR_bool_const_ScalarR_int_int_int(img: *const c_void, pts: *const c_void, is_closed: bool, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_preCornerDetect_const__InputArrayR_const__OutputArrayR_int(src: *const c_void, dst: *const c_void, ksize: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_preCornerDetect_const__InputArrayR_const__OutputArrayR_int_int(src: *const c_void, dst: *const c_void, ksize: i32, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_putText_const__InputOutputArrayR_const_StringR_Point_int_double_Scalar(img: *const c_void, text: *const c_char, org: *const core::Point, font_face: i32, font_scale: f64, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_putText_const__InputOutputArrayR_const_StringR_Point_int_double_Scalar_int_int_bool(img: *const c_void, text: *const c_char, org: *const core::Point, font_face: i32, font_scale: f64, color: *const core::Scalar, thickness: i32, line_type: i32, bottom_left_origin: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_pyrDown_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_pyrDown_const__InputArrayR_const__OutputArrayR_const_SizeR_int(src: *const c_void, dst: *const c_void, dstsize: *const core::Size, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_pyrMeanShiftFiltering_const__InputArrayR_const__OutputArrayR_double_double(src: *const c_void, dst: *const c_void, sp: f64, sr: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_pyrMeanShiftFiltering_const__InputArrayR_const__OutputArrayR_double_double_int_TermCriteria(src: *const c_void, dst: *const c_void, sp: f64, sr: f64, max_level: i32, termcrit: *const core::TermCriteria, ocvrs_return: *mut Result<()>);
		pub fn cv_pyrUp_const__InputArrayR_const__OutputArrayR(src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_pyrUp_const__InputArrayR_const__OutputArrayR_const_SizeR_int(src: *const c_void, dst: *const c_void, dstsize: *const core::Size, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_rectangle_const__InputOutputArrayR_Point_Point_const_ScalarR(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_rectangle_const__InputOutputArrayR_Point_Point_const_ScalarR_int_int_int(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_rectangle_const__InputOutputArrayR_Rect_const_ScalarR(img: *const c_void, rec: *const core::Rect, color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_rectangle_const__InputOutputArrayR_Rect_const_ScalarR_int_int_int(img: *const c_void, rec: *const core::Rect, color: *const core::Scalar, thickness: i32, line_type: i32, shift: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int(src: *const c_void, dst: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_remap_const__InputArrayR_const__OutputArrayR_const__InputArrayR_const__InputArrayR_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, map1: *const c_void, map2: *const c_void, interpolation: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_resize_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_resize_const__InputArrayR_const__OutputArrayR_Size_double_double_int(src: *const c_void, dst: *const c_void, dsize: *const core::Size, fx: f64, fy: f64, interpolation: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_rotatedRectangleIntersection_const_RotatedRectR_const_RotatedRectR_const__OutputArrayR(rect1: *const core::RotatedRect, rect2: *const core::RotatedRect, intersecting_region: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_sepFilter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_const__InputArrayR(src: *const c_void, dst: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_sepFilter2D_const__InputArrayR_const__OutputArrayR_int_const__InputArrayR_const__InputArrayR_Point_double_int(src: *const c_void, dst: *const c_void, ddepth: i32, kernel_x: *const c_void, kernel_y: *const c_void, anchor: *const core::Point, delta: f64, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_spatialGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(src: *const c_void, dx: *const c_void, dy: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_spatialGradient_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_int_int(src: *const c_void, dx: *const c_void, dy: *const c_void, ksize: i32, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_sqrBoxFilter_const__InputArrayR_const__OutputArrayR_int_Size(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_sqrBoxFilter_const__InputArrayR_const__OutputArrayR_int_Size_Point_bool_int(src: *const c_void, dst: *const c_void, ddepth: i32, ksize: *const core::Size, anchor: *const core::Point, normalize: bool, border_type: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_stackBlur_const__InputArrayR_const__OutputArrayR_Size(src: *const c_void, dst: *const c_void, ksize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_thresholdWithMask_const__InputArrayR_const__InputOutputArrayR_const__InputArrayR_double_double_int(src: *const c_void, dst: *const c_void, mask: *const c_void, thresh: f64, maxval: f64, typ: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_threshold_const__InputArrayR_const__OutputArrayR_double_double_int(src: *const c_void, dst: *const c_void, thresh: f64, maxval: f64, typ: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_warpAffine_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_warpPerspective_const__InputArrayR_const__OutputArrayR_const__InputArrayR_Size_int_int_const_ScalarR(src: *const c_void, dst: *const c_void, m: *const c_void, dsize: *const core::Size, flags: i32, border_mode: i32, border_value: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_warpPolar_const__InputArrayR_const__OutputArrayR_Size_Point2f_double_int(src: *const c_void, dst: *const c_void, dsize: *const core::Size, center: *const core::Point2f, max_radius: f64, flags: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_watershed_const__InputArrayR_const__InputOutputArrayR(image: *const c_void, markers: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_wrapperEMD_const__InputArrayR_const__InputArrayR_int(signature1: *const c_void, signature2: *const c_void, dist_type: i32, ocvrs_return: *mut Result<f32>);
		pub fn cv_wrapperEMD_const__InputArrayR_const__InputArrayR_int_const__InputArrayR_PtrLfloatG_const__OutputArrayR(signature1: *const c_void, signature2: *const c_void, dist_type: i32, cost: *const c_void, lower_bound: *mut c_void, flow: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_CLAHE_apply_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, src: *const c_void, dst: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CLAHE_setClipLimit_double(instance: *mut c_void, clip_limit: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_CLAHE_getClipLimit_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_CLAHE_setTilesGridSize_Size(instance: *mut c_void, tile_grid_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_CLAHE_getTilesGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_CLAHE_collectGarbage(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CLAHE_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CLAHE_delete(instance: *mut c_void);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_Point(instance: *mut c_void, templ: *const c_void, templ_center: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR(instance: *mut c_void, templ: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_const__InputArrayR_const__InputArrayR_Point(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, templ_center: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_setTemplate_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, positions: *const c_void, votes: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, positions: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, positions: *const c_void, votes: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_detect_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, edges: *const c_void, dx: *const c_void, dy: *const c_void, positions: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_setCannyLowThresh_int(instance: *mut c_void, canny_low_thresh: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_getCannyLowThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_setCannyHighThresh_int(instance: *mut c_void, canny_high_thresh: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_getCannyHighThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_setMinDist_double(instance: *mut c_void, min_dist: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_getMinDist_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHough_setDp_double(instance: *mut c_void, dp: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_getDp_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHough_setMaxBufferSize_int(instance: *mut c_void, max_buffer_size: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHough_getMaxBufferSize_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHough_to_GeneralizedHoughBallard(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHough_to_GeneralizedHoughGuil(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHough_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHough_delete(instance: *mut c_void);
		pub fn cv_GeneralizedHoughBallard_setLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughBallard_getLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughBallard_setVotesThreshold_int(instance: *mut c_void, votes_threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughBallard_getVotesThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughBallard_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughBallard_to_GeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughBallard_delete(instance: *mut c_void);
		pub fn cv_GeneralizedHoughGuil_setXi_double(instance: *mut c_void, xi: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getXi_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setLevels_int(instance: *mut c_void, levels: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getLevels_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setAngleEpsilon_double(instance: *mut c_void, angle_epsilon: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getAngleEpsilon_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMinAngle_double(instance: *mut c_void, min_angle: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getMinAngle_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMaxAngle_double(instance: *mut c_void, max_angle: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getMaxAngle_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setAngleStep_double(instance: *mut c_void, angle_step: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getAngleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setAngleThresh_int(instance: *mut c_void, angle_thresh: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getAngleThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setMinScale_double(instance: *mut c_void, min_scale: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getMinScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setMaxScale_double(instance: *mut c_void, max_scale: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getMaxScale_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setScaleStep_double(instance: *mut c_void, scale_step: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getScaleStep_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_GeneralizedHoughGuil_setScaleThresh_int(instance: *mut c_void, scale_thresh: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getScaleThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_setPosThresh_int(instance: *mut c_void, pos_thresh: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_GeneralizedHoughGuil_getPosThresh_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_GeneralizedHoughGuil_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughGuil_to_GeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_GeneralizedHoughGuil_delete(instance: *mut c_void);
		pub fn cv_LineIterator_LineIterator_const_MatR_Point_Point_int_bool(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_const_MatR_Point_Point(img: *const c_void, pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Point_Point_int_bool(pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Point_Point(pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Size_Point_Point_int_bool(bounding_area_size: *const core::Size, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Size_Point_Point(bounding_area_size: *const core::Size, pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Rect_Point_Point_int_bool(bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_LineIterator_Rect_Point_Point(bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_init_const_MatX_Rect_Point_Point_int_bool(instance: *mut c_void, img: *const c_void, bounding_area_rect: *const core::Rect, pt1: *const core::Point, pt2: *const core::Point, connectivity: i32, left_to_right: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_LineIterator_operatorX(instance: *mut c_void, ocvrs_return: *mut Result<*mut u8>);
		pub fn cv_LineIterator_operatorAA(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_LineIterator_pos_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point>);
		pub fn cv_LineIterator_propPtr_const(instance: *const c_void) -> *const u8;
		pub fn cv_LineIterator_propPtr(instance: *mut c_void) -> *mut u8;
		pub fn cv_LineIterator_propPtr_unsigned_charX(instance: *mut c_void, val: *const u8);
		pub fn cv_LineIterator_propPtr0_const(instance: *const c_void) -> *const u8;
		pub fn cv_LineIterator_propStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propStep_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propElemSize_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propElemSize_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propErr_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propErr_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propCount_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propCount_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propMinusDelta_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propMinusDelta_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propPlusDelta_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propPlusDelta_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propMinusStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propMinusStep_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propPlusStep_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propPlusStep_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propMinusShift_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propMinusShift_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propPlusShift_const(instance: *const c_void) -> i32;
		pub fn cv_LineIterator_propPlusShift_const_int(instance: *mut c_void, val: i32);
		pub fn cv_LineIterator_propP_const(instance: *const c_void, ocvrs_return: *mut core::Point);
		pub fn cv_LineIterator_propP_const_Point(instance: *mut c_void, val: *const core::Point);
		pub fn cv_LineIterator_propPtmode_const(instance: *const c_void) -> bool;
		pub fn cv_LineIterator_propPtmode_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_LineIterator_delete(instance: *mut c_void);
		pub fn cv_LineSegmentDetector_detect_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, width: *const c_void, prec: *const c_void, nfa: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LineSegmentDetector_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LineSegmentDetector_drawSegments_const__InputOutputArrayR_const__InputArrayR(instance: *mut c_void, image: *const c_void, lines: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_LineSegmentDetector_compareSegments_const_SizeR_const__InputArrayR_const__InputArrayR_const__InputOutputArrayR(instance: *mut c_void, size: *const core::Size, lines1: *const c_void, lines2: *const c_void, image: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LineSegmentDetector_compareSegments_const_SizeR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, size: *const core::Size, lines1: *const c_void, lines2: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_LineSegmentDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_LineSegmentDetector_delete(instance: *mut c_void);
		pub fn cv_Subdiv2D_Subdiv2D(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Subdiv2D_Subdiv2D_Rect(rect: *const core::Rect, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_Subdiv2D_initDelaunay_Rect(instance: *mut c_void, rect: *const core::Rect, ocvrs_return: *mut Result<()>);
		pub fn cv_Subdiv2D_insert_Point2f(instance: *mut c_void, pt: *const core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_insert_const_vectorLPoint2fGR(instance: *mut c_void, ptvec: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Subdiv2D_locate_Point2f_intR_intR(instance: *mut c_void, pt: *const core::Point2f, edge: *mut i32, vertex: *mut i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_findNearest_Point2f_Point2fX(instance: *mut c_void, pt: *const core::Point2f, nearest_pt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_findNearest_Point2f(instance: *mut c_void, pt: *const core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_getEdgeList_const_vectorLVec4fGR(instance: *const c_void, edge_list: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Subdiv2D_getLeadingEdgeList_const_vectorLintGR(instance: *const c_void, leading_edge_list: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Subdiv2D_getTriangleList_const_vectorLVec6fGR(instance: *const c_void, triangle_list: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Subdiv2D_getVoronoiFacetList_const_vectorLintGR_vectorLvectorLPoint2fGGR_vectorLPoint2fGR(instance: *mut c_void, idx: *const c_void, facet_list: *mut c_void, facet_centers: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_Subdiv2D_getVertex_const_int_intX(instance: *const c_void, vertex: i32, first_edge: *mut i32, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_Subdiv2D_getVertex_const_int(instance: *const c_void, vertex: i32, ocvrs_return: *mut Result<core::Point2f>);
		pub fn cv_Subdiv2D_getEdge_const_int_int(instance: *const c_void, edge: i32, next_edge_type: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_nextEdge_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_rotateEdge_const_int_int(instance: *const c_void, edge: i32, rotate: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_symEdge_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeOrg_const_int_Point2fX(instance: *const c_void, edge: i32, orgpt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeOrg_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeDst_const_int_Point2fX(instance: *const c_void, edge: i32, dstpt: *mut core::Point2f, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_edgeDst_const_int(instance: *const c_void, edge: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_Subdiv2D_delete(instance: *mut c_void);
		pub fn cv_segmentation_IntelligentScissorsMB_IntelligentScissorsMB(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setWeights_float_float_float(instance: *mut c_void, weight_non_edge: f32, weight_gradient_direction: f32, weight_gradient_magnitude: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit_float(instance: *mut c_void, gradient_magnitude_threshold_max: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setGradientMagnitudeMaxLimit(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters_float(instance: *mut c_void, gradient_magnitude_min_value: f32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureZeroCrossingParameters(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters_double_double_int_bool(instance: *mut c_void, threshold1: f64, threshold2: f64, aperture_size: i32, l2gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_setEdgeFeatureCannyParameters_double_double(instance: *mut c_void, threshold1: f64, threshold2: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImage_const__InputArrayR(instance: *mut c_void, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImageFeatures_const__InputArrayR_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, non_edge: *const c_void, gradient_direction: *const c_void, gradient_magnitude: *const c_void, image: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_applyImageFeatures_const__InputArrayR_const__InputArrayR_const__InputArrayR(instance: *mut c_void, non_edge: *const c_void, gradient_direction: *const c_void, gradient_magnitude: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_segmentation_IntelligentScissorsMB_buildMap_const_PointR(instance: *mut c_void, source_pt: *const core::Point, ocvrs_return: *mut Result<()>);
		pub fn cv_segmentation_IntelligentScissorsMB_getContour_const_const_PointR_const__OutputArrayR_bool(instance: *const c_void, target_pt: *const core::Point, contour: *const c_void, backward: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_segmentation_IntelligentScissorsMB_getContour_const_const_PointR_const__OutputArrayR(instance: *const c_void, target_pt: *const core::Point, contour: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_segmentation_IntelligentScissorsMB_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_segmentation_IntelligentScissorsMB_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CLAHEG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CLAHEG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_CLAHEG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_CLAHEG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_CLAHEG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GeneralizedHoughG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughBallardG_to_PtrOfGeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_GeneralizedHoughGuilG_to_PtrOfGeneralizedHough(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_LineSegmentDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_LineSegmentDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
	}
}
pub use imgproc_sys::*;

mod objdetect_sys {
	use super::*;

	extern "C" {
		pub fn cv_aruco_drawDetectedCornersCharuco_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, charuco_corners: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_drawDetectedCornersCharuco_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_Scalar(image: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, corner_color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_drawDetectedDiamonds_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, diamond_corners: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_drawDetectedDiamonds_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_Scalar(image: *const c_void, diamond_corners: *const c_void, diamond_ids: *const c_void, border_color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_drawDetectedMarkers_const__InputOutputArrayR_const__InputArrayR(image: *const c_void, corners: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_drawDetectedMarkers_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_Scalar(image: *const c_void, corners: *const c_void, ids: *const c_void, border_color: *const core::Scalar, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_extendDictionary_int_int(n_markers: i32, marker_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_extendDictionary_int_int_const_DictionaryR_int(n_markers: i32, marker_size: i32, base_dictionary: *const c_void, random_seed: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_generateImageMarker_const_DictionaryR_int_int_const__OutputArrayR(dictionary: *const c_void, id: i32, side_pixels: i32, img: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_generateImageMarker_const_DictionaryR_int_int_const__OutputArrayR_int(dictionary: *const c_void, id: i32, side_pixels: i32, img: *const c_void, border_bits: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_getPredefinedDictionary_PredefinedDictionaryType(name: crate::objdetect::PredefinedDictionaryType, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_getPredefinedDictionary_int(dict: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_createFaceDetectionMaskGenerator(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_groupRectangles_meanshift_vectorLRectGR_vectorLdoubleGR_vectorLdoubleGR(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_meanshift_vectorLRectGR_vectorLdoubleGR_vectorLdoubleGR_double_Size(rect_list: *mut c_void, found_weights: *mut c_void, found_scales: *mut c_void, detect_threshold: f64, win_det_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_int(rect_list: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_int_double(rect_list: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_int_double_vectorLintGX_vectorLdoubleGX(rect_list: *mut c_void, group_threshold: i32, eps: f64, weights: *mut c_void, level_weights: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_int(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_int_double(rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_vectorLdoubleGR_int(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_groupRectangles_vectorLRectGR_vectorLintGR_vectorLdoubleGR_int_double(rect_list: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_BaseCascadeClassifier_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_BaseCascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR_double_int_int_Size_Size_bool(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_BaseCascadeClassifier_isOldFormatCascade_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_BaseCascadeClassifier_getOriginalWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_BaseCascadeClassifier_getFeatureType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_BaseCascadeClassifier_getOldCascade(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_setMaskGenerator_const_PtrLMaskGeneratorGR(instance: *mut c_void, mask_generator: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_BaseCascadeClassifier_getMaskGenerator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_BaseCascadeClassifier_delete(instance: *mut c_void);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_generateMask_const_MatR(instance: *mut c_void, src: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_initializeMask_const_MatR(instance: *mut c_void, unnamed: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_BaseCascadeClassifier_MaskGenerator_delete(instance: *mut c_void);
		pub fn cv_CascadeClassifier_CascadeClassifier(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_CascadeClassifier_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_empty_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_read_const_FileNodeR(instance: *mut c_void, node: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_double_int_int_Size_Size(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, num_detections: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR_double_int_int_Size_Size_bool(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, scale_factor: f64, min_neighbors: i32, flags: i32, min_size: *const core::Size, max_size: *const core::Size, output_reject_levels: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_detectMultiScale_const__InputArrayR_vectorLRectGR_vectorLintGR_vectorLdoubleGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, reject_levels: *mut c_void, level_weights: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_isOldFormatCascade_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_getOriginalWindowSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_CascadeClassifier_getFeatureType_const(instance: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_CascadeClassifier_getOldCascade(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_convert_const_StringR_const_StringR(oldcascade: *const c_char, newcascade: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_CascadeClassifier_setMaskGenerator_const_PtrLMaskGeneratorGR(instance: *mut c_void, mask_generator: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_CascadeClassifier_getMaskGenerator(instance: *mut c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_CascadeClassifier_propCc(instance: *mut c_void) -> *mut c_void;
		pub fn cv_CascadeClassifier_propCc_const_PtrLBaseCascadeClassifierG(instance: *mut c_void, val: *const c_void);
		pub fn cv_CascadeClassifier_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_DetectionBasedTracker_PtrLIDetectorG_PtrLIDetectorG_const_ParametersR(main_detector: *mut c_void, tracking_detector: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_run(instance: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DetectionBasedTracker_stop(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_resetTracking(instance: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_process_const_MatR(instance: *mut c_void, image_gray: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_setParameters_const_ParametersR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_DetectionBasedTracker_getParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLRectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLObjectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_getObjects_const_vectorLExtObjectGR(instance: *const c_void, result: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_addObject_const_RectR(instance: *mut c_void, location: *const core::Rect, ocvrs_return: *mut Result<i32>);
		pub fn cv_DetectionBasedTracker_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_ExtObject_ExtObject_int_Rect_ObjectStatus(_id: i32, _location: *const core::Rect, _status: crate::objdetect::DetectionBasedTracker_ObjectStatus, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_ExtObject_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionBasedTracker_ExtObject_propId_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_ExtObject_propId_const_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_ExtObject_propLocation_const(instance: *const c_void, ocvrs_return: *mut core::Rect);
		pub fn cv_DetectionBasedTracker_ExtObject_propLocation_const_Rect(instance: *mut c_void, val: *const core::Rect);
		pub fn cv_DetectionBasedTracker_ExtObject_propStatus_const(instance: *const c_void, ocvrs_return: *mut crate::objdetect::DetectionBasedTracker_ObjectStatus);
		pub fn cv_DetectionBasedTracker_ExtObject_propStatus_const_ObjectStatus(instance: *mut c_void, val: crate::objdetect::DetectionBasedTracker_ObjectStatus);
		pub fn cv_DetectionBasedTracker_ExtObject_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_IDetector_detect_const_MatR_vectorLRectGR(instance: *mut c_void, image: *const c_void, objects: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_IDetector_setMinObjectSize_const_SizeR(instance: *mut c_void, min: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_IDetector_setMaxObjectSize_const_SizeR(instance: *mut c_void, max: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_IDetector_getMinObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_DetectionBasedTracker_IDetector_getMaxObjectSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_DetectionBasedTracker_IDetector_getScaleFactor(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_DetectionBasedTracker_IDetector_setScaleFactor_float(instance: *mut c_void, value: f32, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_IDetector_getMinNeighbours(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_DetectionBasedTracker_IDetector_setMinNeighbours_int(instance: *mut c_void, value: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_DetectionBasedTracker_IDetector_delete(instance: *mut c_void);
		pub fn cv_DetectionBasedTracker_Parameters_Parameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_DetectionBasedTracker_Parameters_propMaxTrackLifetime_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_Parameters_propMaxTrackLifetime_const_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_Parameters_propMinDetectionPeriod_const(instance: *const c_void) -> i32;
		pub fn cv_DetectionBasedTracker_Parameters_propMinDetectionPeriod_const_int(instance: *mut c_void, val: i32);
		pub fn cv_DetectionBasedTracker_Parameters_delete(instance: *mut c_void);
		pub fn cv_DetectionROI_defaultNew_const() -> *mut c_void;
		pub fn cv_DetectionROI_propScale_const(instance: *const c_void) -> f64;
		pub fn cv_DetectionROI_propScale_const_double(instance: *mut c_void, val: f64);
		pub fn cv_DetectionROI_propLocations_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionROI_propLocations_const_vectorLPointG(instance: *mut c_void, val: *const c_void);
		pub fn cv_DetectionROI_propConfidences_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_DetectionROI_propConfidences_const_vectorLdoubleG(instance: *mut c_void, val: *const c_void);
		pub fn cv_DetectionROI_delete(instance: *mut c_void);
		pub fn cv_FaceDetectorYN_setInputSize_const_SizeR(instance: *mut c_void, input_size: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_FaceDetectorYN_getInputSize(instance: *mut c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_FaceDetectorYN_setScoreThreshold_float(instance: *mut c_void, score_threshold: f32, ocvrs_return: *mut Result<()>);
		pub fn cv_FaceDetectorYN_getScoreThreshold(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FaceDetectorYN_setNMSThreshold_float(instance: *mut c_void, nms_threshold: f32, ocvrs_return: *mut Result<()>);
		pub fn cv_FaceDetectorYN_getNMSThreshold(instance: *mut c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_FaceDetectorYN_setTopK_int(instance: *mut c_void, top_k: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_FaceDetectorYN_getTopK(instance: *mut c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FaceDetectorYN_detect_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, image: *const c_void, faces: *const c_void, ocvrs_return: *mut Result<i32>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_StringR_const_SizeR_float_float_int_int_int(model: *const c_char, config: *const c_char, input_size: *const core::Size, score_threshold: f32, nms_threshold: f32, top_k: i32, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_StringR_const_SizeR(model: *const c_char, config: *const c_char, input_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR_const_SizeR_float_float_int_int_int(framework: *const c_char, buffer_model: *const c_void, buffer_config: *const c_void, input_size: *const core::Size, score_threshold: f32, nms_threshold: f32, top_k: i32, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceDetectorYN_create_const_StringR_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR_const_SizeR(framework: *const c_char, buffer_model: *const c_void, buffer_config: *const c_void, input_size: *const core::Size, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceDetectorYN_delete(instance: *mut c_void);
		pub fn cv_FaceRecognizerSF_alignCrop_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, src_img: *const c_void, face_box: *const c_void, aligned_img: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FaceRecognizerSF_feature_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, aligned_img: *const c_void, face_feature: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_FaceRecognizerSF_match_const_const__InputArrayR_const__InputArrayR_int(instance: *const c_void, face_feature1: *const c_void, face_feature2: *const c_void, dis_type: i32, ocvrs_return: *mut Result<f64>);
		pub fn cv_FaceRecognizerSF_match_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, face_feature1: *const c_void, face_feature2: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_StringR_int_int(model: *const c_char, config: *const c_char, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_StringR(model: *const c_char, config: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR_int_int(framework: *const c_char, buffer_model: *const c_void, buffer_config: *const c_void, backend_id: i32, target_id: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_create_const_StringR_const_vectorLunsigned_charGR_const_vectorLunsigned_charGR(framework: *const c_char, buffer_model: *const c_void, buffer_config: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_FaceRecognizerSF_delete(instance: *mut c_void);
		pub fn cv_GraphicalCodeDetector_GraphicalCodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_GraphicalCodeDetector_const_GraphicalCodeDetectorR(unnamed: *const c_void) -> *mut c_void;
		pub fn cv_GraphicalCodeDetector_GraphicalCodeDetector_GraphicalCodeDetectorRR(unnamed: *mut c_void) -> *mut c_void;
		pub fn cv_GraphicalCodeDetector_operatorST_const_GraphicalCodeDetectorR(instance: *mut c_void, unnamed: *const c_void);
		pub fn cv_GraphicalCodeDetector_operatorST_GraphicalCodeDetectorRR(instance: *mut c_void, unnamed: *mut c_void);
		pub fn cv_GraphicalCodeDetector_detect_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_decode_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, straight_code: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_decode_const_const__InputArrayR_const__InputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_detectAndDecode_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, straight_code: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_detectAndDecode_const_const__InputArrayR(instance: *const c_void, img: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_GraphicalCodeDetector_detectMulti_const_const__InputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_decodeMulti_const_const__InputArrayR_const__InputArrayR_vectorLstringGR_const__OutputArrayR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, straight_code: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_decodeMulti_const_const__InputArrayR_const__InputArrayR_vectorLstringGR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_detectAndDecodeMulti_const_const__InputArrayR_vectorLstringGR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, points: *const c_void, straight_code: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_detectAndDecodeMulti_const_const__InputArrayR_vectorLstringGR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_GraphicalCodeDetector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_GraphicalCodeDetector_delete(instance: *mut c_void);
		pub fn cv_HOGDescriptor_HOGDescriptor(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int_int_double_HistogramNormType_double_bool_int_bool(_win_size: *const core::Size, _block_size: *const core::Size, _block_stride: *const core::Size, _cell_size: *const core::Size, _nbins: i32, _deriv_aperture: i32, _win_sigma: f64, _histogram_norm_type: crate::objdetect::HOGDescriptor_HistogramNormType, _l2_hys_threshold: f64, _gamma_correction: bool, _nlevels: i32, _signed_gradient: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_Size_Size_Size_Size_int(_win_size: *const core::Size, _block_size: *const core::Size, _block_stride: *const core::Size, _cell_size: *const core::Size, _nbins: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_const_StringR(filename: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_HOGDescriptor_const_HOGDescriptorR(d: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getDescriptorSize_const(instance: *const c_void, ocvrs_return: *mut Result<size_t>);
		pub fn cv_HOGDescriptor_checkDetectorSize_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_getWinSigma_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_HOGDescriptor_setSVMDetector_const__InputArrayR(instance: *mut c_void, svmdetector: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_read_FileNodeR(instance: *mut c_void, fn_: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_write_const_FileStorageR_const_StringR(instance: *const c_void, fs: *mut c_void, objname: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_load_const_StringR_const_StringR(instance: *mut c_void, filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_load_const_StringR(instance: *mut c_void, filename: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_HOGDescriptor_save_const_const_StringR_const_StringR(instance: *const c_void, filename: *const c_char, objname: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_save_const_const_StringR(instance: *const c_void, filename: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_copyTo_const_HOGDescriptorR(instance: *const c_void, c: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_compute_const_const__InputArrayR_vectorLfloatGR_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, descriptors: *mut c_void, win_stride: *const core::Size, padding: *const core::Size, locations: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_compute_const_const__InputArrayR_vectorLfloatGR(instance: *const c_void, img: *const c_void, descriptors: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_vectorLdoubleGR_double_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_vectorLdoubleGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, weights: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR_double_Size_Size_const_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, search_locations: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detect_const_const__InputArrayR_vectorLPointGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_vectorLdoubleGR_double_Size_Size_double_double_bool(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, found_weights: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, group_threshold: f64, use_meanshift_grouping: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_vectorLdoubleGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, found_weights: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR_double_Size_Size_double_double_bool(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, scale: f64, group_threshold: f64, use_meanshift_grouping: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectMultiScale_const_const__InputArrayR_vectorLRectGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_computeGradient_const_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_Size_Size(instance: *const c_void, img: *const c_void, grad: *const c_void, angle_ofs: *const c_void, padding_tl: *const core::Size, padding_br: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_computeGradient_const_const__InputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, img: *const c_void, grad: *const c_void, angle_ofs: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_getDefaultPeopleDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_getDaimlerPeopleDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_HOGDescriptor_detectROI_const_const__InputArrayR_const_vectorLPointGR_vectorLPointGR_vectorLdoubleGR_double_Size_Size(instance: *const c_void, img: *const c_void, locations: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, hit_threshold: f64, win_stride: *const core::Size, padding: *const core::Size, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectROI_const_const__InputArrayR_const_vectorLPointGR_vectorLPointGR_vectorLdoubleGR(instance: *const c_void, img: *const c_void, locations: *const c_void, found_locations: *mut c_void, confidences: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectMultiScaleROI_const_const__InputArrayR_vectorLRectGR_vectorLDetectionROIGR_double_int(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, locations: *mut c_void, hit_threshold: f64, group_threshold: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_detectMultiScaleROI_const_const__InputArrayR_vectorLRectGR_vectorLDetectionROIGR(instance: *const c_void, img: *const c_void, found_locations: *mut c_void, locations: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_groupRectangles_const_vectorLRectGR_vectorLdoubleGR_int_double(instance: *const c_void, rect_list: *mut c_void, weights: *mut c_void, group_threshold: i32, eps: f64, ocvrs_return: *mut Result<()>);
		pub fn cv_HOGDescriptor_propWinSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propWinSize_const_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propBlockSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propBlockSize_const_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propBlockStride_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propBlockStride_const_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propCellSize_const(instance: *const c_void, ocvrs_return: *mut core::Size);
		pub fn cv_HOGDescriptor_propCellSize_const_Size(instance: *mut c_void, val: *const core::Size);
		pub fn cv_HOGDescriptor_propNbins_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_propNbins_const_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_propDerivAperture_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_propDerivAperture_const_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_propWinSigma_const(instance: *const c_void) -> f64;
		pub fn cv_HOGDescriptor_propWinSigma_const_double(instance: *mut c_void, val: f64);
		pub fn cv_HOGDescriptor_propHistogramNormType_const(instance: *const c_void, ocvrs_return: *mut crate::objdetect::HOGDescriptor_HistogramNormType);
		pub fn cv_HOGDescriptor_propHistogramNormType_const_HistogramNormType(instance: *mut c_void, val: crate::objdetect::HOGDescriptor_HistogramNormType);
		pub fn cv_HOGDescriptor_propL2HysThreshold_const(instance: *const c_void) -> f64;
		pub fn cv_HOGDescriptor_propL2HysThreshold_const_double(instance: *mut c_void, val: f64);
		pub fn cv_HOGDescriptor_propGammaCorrection_const(instance: *const c_void) -> bool;
		pub fn cv_HOGDescriptor_propGammaCorrection_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_HOGDescriptor_propSvmDetector_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_HOGDescriptor_propSvmDetector_const_vectorLfloatG(instance: *mut c_void, val: *const c_void);
		pub fn cv_HOGDescriptor_propOclSvmDetector_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_HOGDescriptor_propOclSvmDetector_const_UMat(instance: *mut c_void, val: *const c_void);
		pub fn cv_HOGDescriptor_propFree_coef_const(instance: *const c_void) -> f32;
		pub fn cv_HOGDescriptor_propFree_coef_const_float(instance: *mut c_void, val: f32);
		pub fn cv_HOGDescriptor_propNlevels_const(instance: *const c_void) -> i32;
		pub fn cv_HOGDescriptor_propNlevels_const_int(instance: *mut c_void, val: i32);
		pub fn cv_HOGDescriptor_propSignedGradient_const(instance: *const c_void) -> bool;
		pub fn cv_HOGDescriptor_propSignedGradient_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_HOGDescriptor_delete(instance: *mut c_void);
		pub fn cv_QRCodeDetector_QRCodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setEpsX_double(instance: *mut c_void, eps_x: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setEpsY_double(instance: *mut c_void, eps_y: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_setUseAlignmentMarkers_bool(instance: *mut c_void, use_alignment_markers: bool, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_decodeCurved_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_decodeCurved_const__InputArrayR_const__InputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectAndDecodeCurved_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *mut c_void, img: *const c_void, points: *const c_void, straight_qrcode: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_detectAndDecodeCurved_const__InputArrayR(instance: *mut c_void, img: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetector_getEncoding_int(instance: *mut c_void, code_idx: i32, ocvrs_return: *mut Result<crate::objdetect::QRCodeEncoder_ECIEncodings>);
		pub fn cv_QRCodeDetector_getEncoding(instance: *mut c_void, ocvrs_return: *mut Result<crate::objdetect::QRCodeEncoder_ECIEncodings>);
		pub fn cv_QRCodeDetector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QRCodeDetector_to_GraphicalCodeDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_QRCodeDetector_delete(instance: *mut c_void);
		pub fn cv_QRCodeDetectorAruco_QRCodeDetectorAruco(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_QRCodeDetectorAruco_const_ParamsR(params: *const crate::objdetect::QRCodeDetectorAruco_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_getDetectorParameters_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::QRCodeDetectorAruco_Params>);
		pub fn cv_QRCodeDetectorAruco_setDetectorParameters_const_ParamsR(instance: *mut c_void, params: *const crate::objdetect::QRCodeDetectorAruco_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_getArucoParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeDetectorAruco_setArucoParameters_const_DetectorParametersR(instance: *mut c_void, params: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_QRCodeDetectorAruco_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_QRCodeDetectorAruco_to_GraphicalCodeDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_QRCodeDetectorAruco_delete(instance: *mut c_void);
		pub fn cv_QRCodeDetectorAruco_Params_Params(ocvrs_return: *mut Result<crate::objdetect::QRCodeDetectorAruco_Params>);
		pub fn cv_QRCodeEncoder_create_const_ParamsR(parameters: *const crate::objdetect::QRCodeEncoder_Params, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeEncoder_create(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_QRCodeEncoder_encode_const_StringR_const__OutputArrayR(instance: *mut c_void, encoded_info: *const c_char, qrcode: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_QRCodeEncoder_encodeStructuredAppend_const_StringR_const__OutputArrayR(instance: *mut c_void, encoded_info: *const c_char, qrcodes: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_QRCodeEncoder_delete(instance: *mut c_void);
		pub fn cv_QRCodeEncoder_Params_Params(ocvrs_return: *mut Result<crate::objdetect::QRCodeEncoder_Params>);
		pub fn cv_SimilarRects_SimilarRects_double(_eps: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_SimilarRects_operator___const_const_RectR_const_RectR(instance: *const c_void, r1: *const core::Rect, r2: *const core::Rect, ocvrs_return: *mut Result<bool>);
		pub fn cv_SimilarRects_propEps_const(instance: *const c_void) -> f64;
		pub fn cv_SimilarRects_propEps_const_double(instance: *mut c_void, val: f64);
		pub fn cv_SimilarRects_delete(instance: *mut c_void);
		pub fn cv_aruco_ArucoDetector_ArucoDetector_const_DictionaryR_const_DetectorParametersR_const_RefineParametersR(dictionary: *const c_void, detector_params: *const c_void, refine_params: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_ArucoDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_ArucoDetector_const_vectorLDictionaryGR_const_DetectorParametersR_const_RefineParametersR(dictionaries: *const c_void, detector_params: *const c_void, refine_params: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_ArucoDetector_const_vectorLDictionaryGR(dictionaries: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_detectMarkers_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, corners: *const c_void, ids: *const c_void, rejected_img_points: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_detectMarkers_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, corners: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_refineDetectedMarkers_const_const__InputArrayR_const_BoardR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputArrayR_const__InputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, rejected_corners: *const c_void, camera_matrix: *const c_void, dist_coeffs: *const c_void, recovered_idxs: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_refineDetectedMarkers_const_const__InputArrayR_const_BoardR_const__InputOutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, image: *const c_void, board: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, rejected_corners: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_detectMarkersMultiDict_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, corners: *const c_void, ids: *const c_void, rejected_img_points: *const c_void, dict_indices: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_detectMarkersMultiDict_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, corners: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_getDictionary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_setDictionary_const_DictionaryR(instance: *mut c_void, dictionary: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_getDictionaries_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_setDictionaries_const_vectorLDictionaryGR(instance: *mut c_void, dictionaries: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_getDetectorParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_ArucoDetector_setDetectorParameters_const_DetectorParametersR(instance: *mut c_void, detector_parameters: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_getRefineParameters_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_ArucoDetector_setRefineParameters_const_RefineParametersR(instance: *mut c_void, refine_parameters: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_write_const_FileStorageR(instance: *const c_void, fs: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_write_FileStorageR_const_StringR(instance: *mut c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_read_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_ArucoDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_ArucoDetector_delete(instance: *mut c_void);
		pub fn cv_aruco_Board_Board_const__InputArrayR_const_DictionaryR_const__InputArrayR(obj_points: *const c_void, dictionary: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getDictionary_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getObjPoints_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getIds_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_getRightBottomCorner_const(instance: *const c_void, ocvrs_return: *mut Result<core::Point3f>);
		pub fn cv_aruco_Board_matchImagePoints_const_const__InputArrayR_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, detected_corners: *const c_void, detected_ids: *const c_void, obj_points: *const c_void, img_points: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Board_generateImage_const_Size_const__OutputArrayR_int_int(instance: *const c_void, out_size: *const core::Size, img: *const c_void, margin_size: i32, border_bits: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Board_generateImage_const_Size_const__OutputArrayR(instance: *const c_void, out_size: *const core::Size, img: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Board_Board(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Board_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_Board_delete(instance: *mut c_void);
		pub fn cv_aruco_CharucoBoard_CharucoBoard_const_SizeR_float_float_const_DictionaryR_const__InputArrayR(size: *const core::Size, square_length: f32, marker_length: f32, dictionary: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_CharucoBoard_const_SizeR_float_float_const_DictionaryR(size: *const core::Size, square_length: f32, marker_length: f32, dictionary: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_setLegacyPattern_bool(instance: *mut c_void, legacy_pattern: bool, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoBoard_getLegacyPattern_const(instance: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_CharucoBoard_getChessboardSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_aruco_CharucoBoard_getSquareLength_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_CharucoBoard_getMarkerLength_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_CharucoBoard_getChessboardCorners_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_getNearestMarkerIdx_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_getNearestMarkerCorners_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_checkCharucoCornersCollinear_const_const__InputArrayR(instance: *const c_void, charuco_ids: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_CharucoBoard_CharucoBoard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoBoard_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoBoard_to_Board(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoBoard_delete(instance: *mut c_void);
		pub fn cv_aruco_CharucoDetector_CharucoDetector_const_CharucoBoardR_const_CharucoParametersR_const_DetectorParametersR_const_RefineParametersR(board: *const c_void, charuco_params: *const c_void, detector_params: *const c_void, refine_params: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_CharucoDetector_const_CharucoBoardR(board: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_getBoard_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_setBoard_const_CharucoBoardR(instance: *mut c_void, board: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_getCharucoParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_setCharucoParameters_CharucoParametersR(instance: *mut c_void, charuco_parameters: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_getDetectorParameters_const(instance: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoDetector_setDetectorParameters_const_DetectorParametersR(instance: *mut c_void, detector_parameters: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_getRefineParameters_const(instance: *const c_void, ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_CharucoDetector_setRefineParameters_const_RefineParametersR(instance: *mut c_void, refine_parameters: *const crate::objdetect::RefineParameters, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_detectBoard_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, image: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, marker_corners: *const c_void, marker_ids: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_detectBoard_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, charuco_corners: *const c_void, charuco_ids: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_detectDiamonds_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR_const__InputOutputArrayR_const__InputOutputArrayR(instance: *const c_void, image: *const c_void, diamond_corners: *const c_void, diamond_ids: *const c_void, marker_corners: *const c_void, marker_ids: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_detectDiamonds_const_const__InputArrayR_const__OutputArrayR_const__OutputArrayR(instance: *const c_void, image: *const c_void, diamond_corners: *const c_void, diamond_ids: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_CharucoDetector_to_Algorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoDetector_delete(instance: *mut c_void);
		pub fn cv_aruco_CharucoParameters_CharucoParameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_CharucoParameters_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoParameters_propCameraMatrix_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoParameters_propCameraMatrix_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_aruco_CharucoParameters_propDistCoeffs_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_CharucoParameters_propDistCoeffs_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_aruco_CharucoParameters_propMinMarkers_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_CharucoParameters_propMinMarkers_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_CharucoParameters_propTryRefineMarkers_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_CharucoParameters_propTryRefineMarkers_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_CharucoParameters_propCheckMarkers_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_CharucoParameters_propCheckMarkers_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_CharucoParameters_delete(instance: *mut c_void);
		pub fn cv_aruco_DetectorParameters_DetectorParameters(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_DetectorParameters_readDetectorParameters_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_DetectorParameters_writeDetectorParameters_FileStorageR_const_StringR(instance: *mut c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_DetectorParameters_writeDetectorParameters_FileStorageR(instance: *mut c_void, fs: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_DetectorParameters_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMin_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMin_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMax_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeMax_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeStep_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshWinSizeStep_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshConstant_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propAdaptiveThreshConstant_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinMarkerPerimeterRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinMarkerPerimeterRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMaxMarkerPerimeterRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMaxMarkerPerimeterRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propPolygonalApproxAccuracyRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propPolygonalApproxAccuracyRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinCornerDistanceRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinCornerDistanceRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinDistanceToBorder_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propMinDistanceToBorder_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propMinMarkerDistanceRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinMarkerDistanceRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinGroupDistance_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propMinGroupDistance_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMethod_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMethod_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementWinSize_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementWinSize_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propRelativeCornerRefinmentWinSize_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propRelativeCornerRefinmentWinSize_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMaxIterations_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMaxIterations_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMinAccuracy_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propCornerRefinementMinAccuracy_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMarkerBorderBits_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propMarkerBorderBits_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemovePixelPerCell_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemovePixelPerCell_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemoveIgnoredMarginPerCell_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propPerspectiveRemoveIgnoredMarginPerCell_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMaxErroneousBitsInBorderRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMaxErroneousBitsInBorderRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propMinOtsuStdDev_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propMinOtsuStdDev_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propErrorCorrectionRate_const(instance: *const c_void) -> f64;
		pub fn cv_aruco_DetectorParameters_propErrorCorrectionRate_const_double(instance: *mut c_void, val: f64);
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadDecimate_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadDecimate_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadSigma_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagQuadSigma_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMinClusterPixels_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMinClusterPixels_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxNmaxima_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxNmaxima_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAprilTagCriticalRad_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagCriticalRad_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxLineFitMse_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMaxLineFitMse_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_propAprilTagMinWhiteBlackDiff_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagMinWhiteBlackDiff_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propAprilTagDeglitch_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propAprilTagDeglitch_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propDetectInvertedMarker_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_DetectorParameters_propDetectInvertedMarker_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_DetectorParameters_propUseAruco3Detection_const(instance: *const c_void) -> bool;
		pub fn cv_aruco_DetectorParameters_propUseAruco3Detection_const_bool(instance: *mut c_void, val: bool);
		pub fn cv_aruco_DetectorParameters_propMinSideLengthCanonicalImg_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_DetectorParameters_propMinSideLengthCanonicalImg_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_DetectorParameters_propMinMarkerLengthRatioOriginalImg_const(instance: *const c_void) -> f32;
		pub fn cv_aruco_DetectorParameters_propMinMarkerLengthRatioOriginalImg_const_float(instance: *mut c_void, val: f32);
		pub fn cv_aruco_DetectorParameters_delete(instance: *mut c_void);
		pub fn cv_aruco_Dictionary_Dictionary(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_Dictionary_const_MatR_int_int(bytes_list: *const c_void, _marker_size: i32, maxcorr: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_Dictionary_const_MatR_int(bytes_list: *const c_void, _marker_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_readDictionary_const_FileNodeR(instance: *mut c_void, fn_: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_Dictionary_writeDictionary_FileStorageR_const_StringR(instance: *mut c_void, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Dictionary_writeDictionary_FileStorageR(instance: *mut c_void, fs: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Dictionary_identify_const_const_MatR_intR_intR_double(instance: *const c_void, only_bits: *const c_void, idx: *mut i32, rotation: *mut i32, max_correction_rate: f64, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_Dictionary_getDistanceToId_const_const__InputArrayR_int_bool(instance: *const c_void, bits: *const c_void, id: i32, all_rotations: bool, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_Dictionary_getDistanceToId_const_const__InputArrayR_int(instance: *const c_void, bits: *const c_void, id: i32, ocvrs_return: *mut Result<i32>);
		pub fn cv_aruco_Dictionary_generateImageMarker_const_int_int_const__OutputArrayR_int(instance: *const c_void, id: i32, side_pixels: i32, _img: *const c_void, border_bits: i32, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Dictionary_generateImageMarker_const_int_int_const__OutputArrayR(instance: *const c_void, id: i32, side_pixels: i32, _img: *const c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_aruco_Dictionary_getByteListFromBits_const_MatR(bits: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_getBitsFromByteList_const_MatR_int(byte_list: *const c_void, marker_size: i32, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_Dictionary_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_Dictionary_propBytesList_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_Dictionary_propBytesList_const_Mat(instance: *mut c_void, val: *const c_void);
		pub fn cv_aruco_Dictionary_propMarkerSize_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_Dictionary_propMarkerSize_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_Dictionary_propMaxCorrectionBits_const(instance: *const c_void) -> i32;
		pub fn cv_aruco_Dictionary_propMaxCorrectionBits_const_int(instance: *mut c_void, val: i32);
		pub fn cv_aruco_Dictionary_delete(instance: *mut c_void);
		pub fn cv_aruco_GridBoard_GridBoard_const_SizeR_float_float_const_DictionaryR_const__InputArrayR(size: *const core::Size, marker_length: f32, marker_separation: f32, dictionary: *const c_void, ids: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_GridBoard_GridBoard_const_SizeR_float_float_const_DictionaryR(size: *const core::Size, marker_length: f32, marker_separation: f32, dictionary: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_GridBoard_getGridSize_const(instance: *const c_void, ocvrs_return: *mut Result<core::Size>);
		pub fn cv_aruco_GridBoard_getMarkerLength_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_GridBoard_getMarkerSeparation_const(instance: *const c_void, ocvrs_return: *mut Result<f32>);
		pub fn cv_aruco_GridBoard_GridBoard(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_aruco_GridBoard_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_aruco_GridBoard_to_Board(instance: *mut c_void) -> *mut c_void;
		pub fn cv_aruco_GridBoard_delete(instance: *mut c_void);
		pub fn cv_aruco_RefineParameters_RefineParameters_float_float_bool(min_rep_distance: f32, error_correction_rate: f32, check_all_orders: bool, ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_RefineParameters_RefineParameters(ocvrs_return: *mut Result<crate::objdetect::RefineParameters>);
		pub fn cv_aruco_RefineParameters_readRefineParameters_const_FileNodeR(instance: *const crate::objdetect::RefineParameters, fn_: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_RefineParameters_writeRefineParameters_FileStorageR_const_StringR(instance: *const crate::objdetect::RefineParameters, fs: *mut c_void, name: *const c_char, ocvrs_return: *mut Result<bool>);
		pub fn cv_aruco_RefineParameters_writeRefineParameters_FileStorageR(instance: *const crate::objdetect::RefineParameters, fs: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_BarcodeDetector(ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_BarcodeDetector_const_stringR_const_stringR(prototxt_path: *const c_char, model_path: *const c_char, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_decodeWithType_const_const__InputArrayR_const__InputArrayR_vectorLstringGR_vectorLstringGR(instance: *const c_void, img: *const c_void, points: *const c_void, decoded_info: *mut c_void, decoded_type: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_detectAndDecodeWithType_const_const__InputArrayR_vectorLstringGR_vectorLstringGR_const__OutputArrayR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, decoded_type: *mut c_void, points: *const c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_detectAndDecodeWithType_const_const__InputArrayR_vectorLstringGR_vectorLstringGR(instance: *const c_void, img: *const c_void, decoded_info: *mut c_void, decoded_type: *mut c_void, ocvrs_return: *mut Result<bool>);
		pub fn cv_barcode_BarcodeDetector_getDownsamplingThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_barcode_BarcodeDetector_setDownsamplingThreshold_double(instance: *mut c_void, thresh: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_getDetectorScales_const_vectorLfloatGR(instance: *const c_void, sizes: *mut c_void, ocvrs_return: *mut Result<()>);
		pub fn cv_barcode_BarcodeDetector_setDetectorScales_const_vectorLfloatGR(instance: *mut c_void, sizes: *const c_void, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_getGradientThreshold_const(instance: *const c_void, ocvrs_return: *mut Result<f64>);
		pub fn cv_barcode_BarcodeDetector_setGradientThreshold_double(instance: *mut c_void, thresh: f64, ocvrs_return: *mut Result<*mut c_void>);
		pub fn cv_barcode_BarcodeDetector_implicitClone_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_barcode_BarcodeDetector_to_GraphicalCodeDetector(instance: *mut c_void) -> *mut c_void;
		pub fn cv_barcode_BarcodeDetector_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_ArucoDetectorG_new_const_ArucoDetector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifierG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_BaseCascadeClassifierG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_BaseCascadeClassifier_MaskGeneratorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_to_PtrOfAlgorithm(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_aruco_CharucoDetectorG_new_const_CharucoDetector(val: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_DetectionBasedTracker_IDetectorG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FaceDetectorYNG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceDetectorYNG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceDetectorYNG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_FaceDetectorYNG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_FaceRecognizerSFG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceRecognizerSFG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_FaceRecognizerSFG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_FaceRecognizerSFG_delete(instance: *mut c_void);
		pub fn cv_PtrLcv_QRCodeEncoderG_getInnerPtr_const(instance: *const c_void) -> *mut c_void;
		pub fn cv_PtrLcv_QRCodeEncoderG_getInnerPtrMut(instance: *mut c_void) -> *mut c_void;
		pub fn cv_PtrLcv_QRCodeEncoderG_new_null_const() -> *mut c_void;
		pub fn cv_PtrLcv_QRCodeEncoderG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_push_const_ExtObject(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_insert_size_t_const_ExtObject(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ExtObjectG_set_size_t_const_ExtObject(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_push_const_Object(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_insert_size_t_const_Object(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_DetectionBasedTracker_ObjectG_set_size_t_const_Object(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionROIG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_DetectionROIG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionROIG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_DetectionROIG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_DetectionROIG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_DetectionROIG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_DetectionROIG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_DetectionROIG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_push_const_DetectionROI(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_DetectionROIG_insert_size_t_const_DetectionROI(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_DetectionROIG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_DetectionROIG_set_size_t_const_DetectionROI(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_new_const() -> *mut c_void;
		pub fn std_vectorLcv_aruco_DictionaryG_delete(instance: *mut c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_len_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_aruco_DictionaryG_isEmpty_const(instance: *const c_void) -> bool;
		pub fn std_vectorLcv_aruco_DictionaryG_capacity_const(instance: *const c_void) -> size_t;
		pub fn std_vectorLcv_aruco_DictionaryG_shrinkToFit(instance: *mut c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_reserve_size_t(instance: *mut c_void, additional: size_t);
		pub fn std_vectorLcv_aruco_DictionaryG_remove_size_t(instance: *mut c_void, index: size_t);
		pub fn std_vectorLcv_aruco_DictionaryG_swap_size_t_size_t(instance: *mut c_void, index1: size_t, index2: size_t);
		pub fn std_vectorLcv_aruco_DictionaryG_clear(instance: *mut c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_push_const_Dictionary(instance: *mut c_void, val: *const c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_insert_size_t_const_Dictionary(instance: *mut c_void, index: size_t, val: *const c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_get_const_size_t(instance: *const c_void, index: size_t, ocvrs_return: *mut *mut c_void);
		pub fn std_vectorLcv_aruco_DictionaryG_set_size_t_const_Dictionary(instance: *mut c_void, index: size_t, val: *const c_void);
	}
}
pub use objdetect_sys::*;

pub use crate::manual::sys::*;
